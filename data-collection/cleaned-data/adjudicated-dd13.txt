0	adjudicated	label-na	"def benchmark(f: Callable[[], Any], iters: Optional[int] = None,<newline>              warmup: Optional[int] = None, name: Optional[str] = None,<newline>              target_total_secs: Optional[Union[int, float]] = None):<newline>  """"""Benchmarks ``f``. Prints the results and returns the raw times.<newline>  """""""
1	adjudicated	label-na	"def benchmark_suite(prepare: Callable[..., Callable], params_list: List[Dict],<newline>                    name: str, target_total_secs: Optional[int] = None):<newline>  """"""Benchmarks a function for several combinations of parameters.<newline>  """""""
2	adjudicated	label-na	"def _get_baseline_means(baseline_dir, name):<newline>  baseline_dir = os.path.expanduser(baseline_dir)<newline>  filename = os.path.join(baseline_dir, name + "".csv"")<newline>  if not os.path.exists(filename):<newline>    raise FileNotFoundError(""Can't find baseline file: %s"" % filename)<newline>  with open(filename, newline="""") as csvfile:<newline>    reader = csv.reader(csvfile)<newline>    header = next(reader)<newline>    mean_idx = header.index(""mean"")<newline>    return [float(row[mean_idx]) for row in reader]"
3	adjudicated	label-na	"def _export_results(data_header, data, export_dir, name):<newline>  assert ""mean"" in data_header # For future comparisons via _get_baseline_means<newline>  export_dir = os.path.expanduser(export_dir)<newline>  os.makedirs(export_dir, exist_ok=True)<newline>  filename = os.path.join(export_dir, name + "".csv"")<newline>  with open(filename, ""w"", newline="""") as csvfile:<newline>    writer = csv.writer(csvfile)<newline>    writer.writerow(data_header)<newline>    writer.writerows(data)<newline>  return filename"
4	adjudicated	label-na	def _param_str(param):<newline>  if callable(param):<newline>    return param.__name__<newline>  return str(param)
5	adjudicated	label-na	def math_benchmark(*args):<newline>  def decorator(func):<newline>    for test_case in args[0]:
6	adjudicated	label-na	def wrapper(state, test_case=test_case):<newline>  return func(state, **test_case)
7	adjudicated	label-na	def jax_unary(state, **kwargs):<newline>  shape = kwargs['shape']<newline>  dtype = kwargs['dtype']<newline>  op = kwargs['op']<newline>  input0 = np.random.random(shape).astype(dtype)<newline>  f = op<newline>  f_jitted = jax.jit(f)<newline>  f_jitted(input0).block_until_ready()<newline>  while state:<newline>    f_jitted(input0).block_until_ready()<newline>  state.counters['items_per_second'] = Counter(<newline>      input0.size * state.iterations, Counter.kIsRate<newline>  )
8	adjudicated	label-na	def jax_binary_op(state, **kwargs):<newline>  mkn = kwargs['mkn']<newline>  m = mkn[0]<newline>  k = mkn[1]<newline>  n = mkn[2]<newline>  dtype = kwargs['dtype']<newline>  op = kwargs['op']<newline>  a = np.random.random([m, k]).astype(dtype)<newline>  b = np.random.random([k, n]).astype(dtype)<newline>  f = op<newline>  f_jitted = jax.jit(f)<newline>  f_jitted(a, b).block_until_ready()<newline>  while state:<newline>    f_jitted(a, b).block_until_ready()<newline>  state.counters['items_per_second'] = Counter(<newline>      state.iterations, Counter.kIsRate<newline>  )
9	adjudicated	label-na	def get_regions():<newline>    return requests.post(_API_URL, json={'name':'list_regions'},<newline>                         auth=_API_AUTH, timeout=_REQUEST_TIMEOUT_SECONDS).json()['regions']
10	adjudicated	label-na	def find_existing_cluster():<newline>    return requests.post(_API_URL, json={'name':'find_cluster'},<newline>                         auth=_API_AUTH, timeout=_REQUEST_TIMEOUT_SECONDS).json()['region']
11	adjudicated	label-na	def get_cluster_ip(region):<newline>    return requests.post(_API_URL, json={'name':'get_cluster_ip', 'region':region},<newline>                         auth=_API_AUTH, timeout=_REQUEST_TIMEOUT_SECONDS).json()['cluster_ip']
12	adjudicated	label-na	def get_cluster_username(region):<newline>    return requests.post(_API_URL, json={'name':'get_cluster_username', 'region':region},<newline>                         auth=_API_AUTH, timeout=_REQUEST_TIMEOUT_SECONDS).json()['cluster_username']
13	adjudicated	label-na	def create_cluster(region):<newline>    logging.debug(requests.post(_API_URL, json={'name':'create_cluster', 'region':region},<newline>                                auth=_API_AUTH, timeout=_REQUEST_TIMEOUT_SECONDS))
14	adjudicated	label-na	"class DefaultReport:<newline>  outcome : str = ""none"""
15	adjudicated	label-na	"def parse_line(line):<newline>  # TODO(jakevdp): should we parse other report types?<newline>  parsed = json.loads(line)<newline>  if parsed.get(""$report_type"") == ""TestReport"":<newline>    return TestReport._from_json(parsed)<newline>  return DefaultReport()"
16	adjudicated	label-na	"def main(logfile, outfile):<newline>  logging.info(""Parsing %s"", logfile)<newline>  try:<newline>    with open(logfile, 'r') as f:<newline>      reports = (parse_line(line) for line in f)<newline>      failures = (r for r in reports if r.outcome == ""failed"")<newline>      summary = ""\n"".join(f""{f.nodeid}: {f.longrepr.chain[0][1].message}""<newline>                          for f in failures)<newline>    logging.info(""Parsed summary:\n%s"", summary)<newline>  except Exception:<newline>    err_info = traceback.format_exc()<newline>    logging.info(""Parsing failed:\n%s"", err_info)<newline>    summary = f""Log parsing failed; traceback:\n\n{err_info}""<newline>  logging.info(""Writing result to %s"", outfile)<newline>  with open(outfile, 'w') as f:<newline>    f.write(MSG_FORMAT.format(summary=summary))"
17	adjudicated	label-na	class AnEnum(enum.IntEnum):<newline>  A = 123<newline>  B = 456
18	adjudicated	label-na	"def required_devices(num_devices_required):<newline>  """"""Helper to skip benchmarks that require more devices.""""""<newline>  def helper1(f):<newline>    @functools.wraps(f)<newline>    def helper2(state):<newline>      if jax.device_count() < num_devices_required:<newline>        state.skip_with_error(f""requires {num_devices_required} devices"")<newline>        return<newline>      return f(state)<newline>    return helper2<newline>  return helper1"
19	adjudicated	label-na	"def create_mesh(shape, axis_names, state):<newline>  size = np.prod(shape)<newline>  if len(jax.devices()) < size:<newline>    state.skip_with_error(f""Requires {size} devices"")<newline>    return None<newline>  devices = sorted(jax.devices(), key=lambda d: d.id)<newline>  mesh_devices = np.array(devices[:size]).reshape(shape)<newline>  global_mesh = jax.sharding.Mesh(mesh_devices, axis_names)<newline>  return global_mesh"
20	adjudicated	label-na	"def is_windows():<newline>  return sys.platform.startswith(""win32"")"
21	adjudicated	label-na	"def shell(cmd):<newline>  try:<newline>    output = subprocess.check_output(cmd)<newline>  except subprocess.CalledProcessError as e:<newline>    print(e.output)<newline>    raise<newline>  return output.decode(""UTF-8"").strip()"
22	adjudicated	label-na	"def get_python_bin_path(python_bin_path_flag):<newline>  """"""Returns the path to the Python interpreter to use.""""""<newline>  path = python_bin_path_flag or sys.executable<newline>  return path.replace(os.sep, ""/"")"
23	adjudicated	label-na	"def get_python_version(python_bin_path):<newline>  version_output = shell(<newline>    [python_bin_path, ""-c"",<newline>     (""import sys; print(\""{}.{}\"".format(sys.version_info[0], ""<newline>      ""sys.version_info[1]))"")])<newline>  major, minor = map(int, version_output.split("".""))<newline>  return major, minor"
24	adjudicated	label-na	"def check_python_version(python_version):<newline>  if python_version < (3, 8):<newline>    print(""ERROR: JAX requires Python 3.8 or newer, found "", python_version)<newline>    sys.exit(-1)"
25	adjudicated	label-na	def get_benchmark_fn(nargs, nshards):<newline>  pmap_fn = pmap(lambda *args: jnp.sum(jnp.array(args)))<newline>  shape = (nshards, 4)<newline>  args = [np.random.random(shape) for _ in range(nargs)]<newline>  sharded_args = pmap(lambda x: x)(args)<newline>  assert all(isinstance(arg, jax.Array) for arg in sharded_args)<newline>  def benchmark_fn():<newline>    for _ in range(100):<newline>      pmap_fn(*sharded_args)<newline>  return benchmark_fn
26	adjudicated	label-na	def benchmark_fn():<newline>  for _ in range(100):<newline>    pmap_fn(*sharded_args)<newline>return benchmark_fn
27	adjudicated	label-na	def get_benchmark_fn(nargs, nshards):<newline>  pmap_fn = pmap(lambda *args: jnp.sum(jnp.array(args)))<newline>  shape = (nshards, 4)<newline>  args = [jnp.array(np.random.random(shape)) for _ in range(nargs)]<newline>  assert all(isinstance(arg, jax.Array) for arg in args)<newline>  def benchmark_fn():<newline>    for _ in range(10):<newline>      pmap_fn(*args)<newline>  return benchmark_fn
28	adjudicated	label-na	"def main(logfile: str, outmd: str, outjson: str, name: str):<newline>    print(f""Extracting content of {logfile}"")<newline>    print(f""and writing to {outmd} and {outjson}"")"
29	adjudicated	label-na	class MakeCutouts(nn.Module):<newline>  def __init__(self, cut_size, cut_power=1.0):<newline>      super().__init__()
30	adjudicated	label-na	"class CLIPGuidedStableDiffusion(DiffusionPipeline):<newline>    """"""CLIP guided stable diffusion based on the amazing repo by @crowsonkb and @Jack000<newline>    - https://github.com/Jack000/glid-3-xl<newline>    - https://github.dev/crowsonkb/k-diffusion<newline>    """"""<newline><newline>    def __init__(self, cut_size, cut_power=1.0):<newline>        super().__init__()<newline><newline>    def forward(self, pixel_values, num_cutouts):<newline>    sideY, sideX = pixel_values.shape[2:4]<newline>    max_size = min(sideX, sideY)<newline>    min_size = min(sideX, sideY, self.cut_size)<newline>    cutouts = []<newline>    for _ in range(num_cutouts):<newline>        size = int(torch.rand([]) ** self.cut_power * (max_size - min_size) + min_size)<newline>        offsetx = torch.randint(0, sideX - size + 1, ())<newline>        offsety = torch.randint(0, sideY - size + 1, ())<newline>        cutout = pixel_values[:, :, offsety : offsety + size, offsetx : offsetx + size]<newline>        cutouts.append(F.adaptive_avg_pool2d(cutout, self.cut_size))<newline>    return torch.cat(cutouts)<newline><newline>    def spherical_dist_loss(x, y):<newline>    x = F.normalize(x, dim=-1)<newline>    y = F.normalize(y, dim=-1)<newline>    return (x - y).norm(dim=-1).div(2).arcsin().pow(2).mul(2)"
31	adjudicated	label-na	"class DDIMNoiseComparativeAnalysisPipeline(DiffusionPipeline):<newline>    r""""""<newline>    This model inherits from [`DiffusionPipeline`]. Check the superclass documentation for the generic methods the<newline>    library implements for all the pipelines (such as downloading or saving, running on a particular device, etc.)<newline>    """""""
32	adjudicated	label-na	def preprocess(image):<newline>    if isinstance(image, torch.Tensor):<newline>        return image<newline>    elif isinstance(image, PIL.Image.Image):<newline>        image = [image]
33	adjudicated	label-na	"def check_inputs(self, strength):<newline>    if strength < 0 or strength > 1:<newline>        raise ValueError(f""The value of strength should in [0.0, 1.0] but is {strength}"")"
34	adjudicated	label-na	def get_timesteps(self, num_inference_steps, strength, device):<newline>    # get the original timestep using init_timestep<newline>    init_timestep = min(int(num_inference_steps * strength), num_inference_steps)
35	adjudicated	label-na	"class CheckpointMergerPipeline(DiffusionPipeline):<newline>    """"""<newline>    A class that that supports merging diffusion models based on the discussion here:<newline>    https://github.com/huggingface/diffusers/issues/877<newline><newline>    def __init__(self):<newline>        self.register_to_config()<newline>        super().__init__()<newline><newline>    def _compare_model_configs(self, dict0, dict1):<newline>        if dict0 == dict1:<newline>            return True<newline>        else:<newline>            config0, meta_keys0 = self._remove_meta_keys(dict0)<newline>            config1, meta_keys1 = self._remove_meta_keys(dict1)<newline>            if config0 == config1:<newline>                print(f""Warning !: Mismatch in keys {meta_keys0} and {meta_keys1}."")<newline>                return True<newline>        return False<newline><newline>    def _remove_meta_keys(self, config_dict: Dict):<newline>        meta_keys = []<newline>        temp_dict = config_dict.copy()<newline>        for key in config_dict.keys():<newline>            if key.startswith(""_""):<newline>                temp_dict.pop(key)<newline>                meta_keys.append(key)<newline>        return (temp_dict, meta_keys)"
36	adjudicated	label-na	"class ImagicStableDiffusionPipeline(DiffusionPipeline):<newline>    r""""""<newline>    Pipeline for imagic image editing.<newline>    See paper here: https://arxiv.org/pdf/2210.09276.pdf<newline>    """""""
37	adjudicated	label-na	"def preprocess(image):<newline>    w, h = image.size<newline>    w, h = map(lambda x: x - x % 32, (w, h))  # resize to integer multiple of 32<newline>    image = image.resize((w, h), resample=PIL_INTERPOLATION[""lanczos""])<newline>    image = np.array(image).astype(np.float32) / 255.0<newline>    image = image[None].transpose(0, 3, 1, 2)<newline>    image = torch.from_numpy(image)<newline>    return 2.0 * image - 1.0"
38	adjudicated	label-na	"def enable_attention_slicing(self, slice_size: Optional[Union[str, int]] = ""auto""):<newline>    r""""""<newline>    Enable sliced attention computation.<newline>    When this option is enabled, the attention module will split the input tensor in slices, to compute attention<newline>    in several steps. This is useful to save some memory in exchange for a small speed decrease.<newline>    Args:<newline>        slice_size (`str` or `int`, *optional*, defaults to `""auto""`):<newline>            When `""auto""`, halves the input to the attention heads, so attention will be computed in two steps. If<newline>            a number is provided, uses as many slices as `attention_head_dim // slice_size`. In this case,<newline>            `attention_head_dim` must be a multiple of `slice_size`.<newline>    """"""<newline>    if slice_size == ""auto"":<newline>        # half the attention head size is usually a good trade-off between<newline>        # speed and memory<newline>        slice_size = self.unet.config.attention_head_dim // 2<newline>    self.unet.set_attention_slice(slice_size)"
39	adjudicated	label-na	"def disable_attention_slicing(self):<newline>    r""""""<newline>    Disable sliced attention computation. If `enable_attention_slicing` was previously invoked, this method will go<newline>    back to computing attention in one step.<newline>    """"""<newline>    # set slice_size = `None` to disable `attention slicing`<newline>    self.enable_attention_slicing(None)"
40	adjudicated	label-na	"class ComposableStableDiffusionPipeline(DiffusionPipeline):<newline>    r""""""<newline>    Pipeline for text-to-image generation using Stable Diffusion."
41	adjudicated	label-na	def __init__(<newline>    self,<newline>    vae: AutoencoderKL,<newline>    text_encoder: CLIPTextModel,<newline>    tokenizer: CLIPTokenizer,<newline>    unet: UNet2DConditionModel,<newline>    scheduler: Union[<newline>        DDIMScheduler,<newline>        PNDMScheduler,<newline>        LMSDiscreteScheduler,<newline>        EulerDiscreteScheduler,<newline>        EulerAncestralDiscreteScheduler,<newline>        DPMSolverMultistepScheduler,<newline>    ],<newline>    safety_checker: StableDiffusionSafetyChecker,<newline>    feature_extractor: CLIPFeatureExtractor,<newline>    requires_safety_checker: bool = True,<newline>):<newline>    super().__init__()
42	adjudicated	label-na	"def enable_vae_slicing(self):<newline>    r""""""<newline>    Enable sliced VAE decoding.<newline>    """""""
43	adjudicated	label-na	"def disable_vae_slicing(self):<newline>    r""""""<newline>    Disable sliced VAE decoding. If `enable_vae_slicing` was previously invoked, this method will go back to<newline>    computing decoding in one step.<newline>    """"""<newline>    self.vae.disable_slicing()"
44	adjudicated	label-na	"def enable_sequential_cpu_offload(self, gpu_id=0):<newline>    r""""""<newline>    Offloads all models to CPU using accelerate, significantly reducing memory usage. When called, unet,<newline>    text_encoder, vae and safety checker have their state dicts saved to CPU and then are moved to a<newline>    `torch.device('meta') and loaded to GPU only when their specific submodule has its `forward` method called.<newline>    """"""<newline>    if is_accelerate_available():<newline>        from accelerate import cpu_offload<newline>    else:<newline>        raise ImportError(""Please install accelerate via `pip install accelerate`"")"
45	adjudicated	label-na	"def prepare_mask_and_masked_image(image, mask):<newline>    image = np.array(image.convert(""RGB""))<newline>    image = image[None].transpose(0, 3, 1, 2)<newline>    image = torch.from_numpy(image).to(dtype=torch.float32) / 127.5 - 1.0"
46	adjudicated	label-na	def check_size(image, height, width):<newline>    if isinstance(image, PIL.Image.Image):<newline>        w, h = image.size<newline>    elif isinstance(image, torch.Tensor):<newline>        *_, h, w = image.shape
47	adjudicated	label-na	"def overlay_inner_image(image, inner_image, paste_offset: Tuple[int] = (0, 0)):<newline>    inner_image = inner_image.convert(""RGBA"")<newline>    image = image.convert(""RGB"")"
48	adjudicated	label-na	class BitDiffusion(DiffusionPipeline):<newline>    def __init__(<newline>        self,<newline>        unet: UNet2DConditionModel,<newline>        scheduler: Union[DDIMScheduler, DDPMScheduler],<newline>        bit_scale: Optional[float] = 1.0,<newline>    ):<newline>        super().__init__()<newline>        self.bit_scale = bit_scale<newline>        self.scheduler.step = (<newline>            ddim_bit_scheduler_step if isinstance(scheduler, DDIMScheduler) else ddpm_bit_scheduler_step<newline>        )
49	adjudicated	label-na	"def decimal_to_bits(x, bits=BITS):<newline>    """"""expects image tensor ranging from 0 to 1, outputs bit tensor ranging from -1 to 1""""""<newline>    device = x.device"
50	adjudicated	label-na	"def bits_to_decimal(x, bits=BITS):<newline>    """"""expects bits from -1 to 1, outputs image tensor from 0 to 1""""""<newline>    device = x.device"
51	adjudicated	label-na	"def ddim_bit_scheduler_step(<newline>    self,<newline>    model_output: torch.FloatTensor,<newline>    timestep: int,<newline>    sample: torch.FloatTensor,<newline>    eta: float = 0.0,<newline>    use_clipped_model_output: bool = True,<newline>    generator=None,<newline>    return_dict: bool = True,<newline>) -> Union[DDIMSchedulerOutput, Tuple]:<newline>    """"""<newline>    Predict the sample at the previous timestep by reversing the SDE. Core function to propagate the diffusion<newline>    process from the learned model outputs (most often the predicted noise).<newline>    Args:<newline>        model_output (`torch.FloatTensor`): direct output from learned diffusion model.<newline>        timestep (`int`): current discrete timestep in the diffusion chain.<newline>        sample (`torch.FloatTensor`):<newline>            current instance of sample being created by diffusion process.<newline>        eta (`float`): weight of noise for added noise in diffusion step.<newline>        use_clipped_model_output (`bool`): TODO<newline>        generator: random number generator.<newline>        return_dict (`bool`): option for returning tuple rather than DDIMSchedulerOutput class<newline>    Returns:<newline>        [`~schedulers.scheduling_utils.DDIMSchedulerOutput`] or `tuple`:<newline>        [`~schedulers.scheduling_utils.DDIMSchedulerOutput`] if `return_dict` is True, otherwise a `tuple`. When<newline>        returning a tuple, the first element is the sample tensor.<newline>    """"""<newline>    if self.num_inference_steps is None:<newline>        raise ValueError(<newline>            ""Number of inference steps is 'None', you need to run 'set_timesteps' after creating the scheduler""<newline>        )"
52	adjudicated	label-na	"def ddpm_bit_scheduler_step(<newline>    self,<newline>    model_output: torch.FloatTensor,<newline>    timestep: int,<newline>    sample: torch.FloatTensor,<newline>    prediction_type=""epsilon"",<newline>    generator=None,<newline>    return_dict: bool = True,<newline>) -> Union[DDPMSchedulerOutput, Tuple]:<newline>    """"""<newline>    Predict the sample at the previous timestep by reversing the SDE. Core function to propagate the diffusion<newline>    process from the learned model outputs (most often the predicted noise).<newline>    Args:<newline>        model_output (`torch.FloatTensor`): direct output from learned diffusion model.<newline>        timestep (`int`): current discrete timestep in the diffusion chain.<newline>        sample (`torch.FloatTensor`):<newline>            current instance of sample being created by diffusion process.<newline>        prediction_type (`str`, default `epsilon`):<newline>            indicates whether the model predicts the noise (epsilon), or the samples (`sample`).<newline>        generator: random number generator.<newline>        return_dict (`bool`): option for returning tuple rather than DDPMSchedulerOutput class<newline>    Returns:<newline>        [`~schedulers.scheduling_utils.DDPMSchedulerOutput`] or `tuple`:<newline>        [`~schedulers.scheduling_utils.DDPMSchedulerOutput`] if `return_dict` is True, otherwise a `tuple`. When<newline>        returning a tuple, the first element is the sample tensor.<newline>    """"""<newline>    t = timestep"
53	adjudicated	label-na	def set_seed(seed: int):<newline>    hf_set_seed(seed)
54	adjudicated	label-na	"class Entity:<newline>    """"""<newline>    Internal class to represent entities while converting biomedical NER corpora to a standardized format<newline>    (only used for pre-processing purposes!). Each entity consists of the char span it addresses in<newline>    the original text as well as the type of entity (e.g. Chemical, Gene, and so on).<newline>    """""""
55	adjudicated	label-na	class DpEntry(NamedTuple):<newline>    position_end: int<newline>    entity_count: int<newline>    entity_lengths_sum: int<newline>    last_entity: Optional[Entity]
56	adjudicated	label-na	"class ClassificationCorpus(Corpus):<newline>    """"""<newline>    A classification corpus from FastText-formatted text files.<newline>    """""""
57	adjudicated	label-na	"class ClassificationDataset(FlairDataset):<newline>    """"""<newline>    Dataset for classification instantiated from a single FastText-formatted file.<newline>    """""""
58	adjudicated	label-na	"class CSVClassificationCorpus(Corpus):<newline>    """"""<newline>    Classification corpus instantiated from CSV data files.<newline>    """""""
59	adjudicated	label-na	"class CSVClassificationDataset(FlairDataset):<newline>    """"""<newline>    Dataset for text classification from CSV column formatted data.<newline>    """""""
60	adjudicated	label-na	"def main():<newline>    print(""#### Versions:"")<newline>    print(f""##### Flair\n{flair.__version__}"")<newline>    print(f""##### Pytorch\n{torch.__version__}"")<newline>    print(f""##### Transformers\n{transformers.__version__}"")<newline>    print(f""#### GPU\n{torch.cuda.is_available()}"")"
61	adjudicated	label-na	class DataLoader(torch.utils.data.dataloader.DataLoader):<newline>    def __init__(<newline>        self,<newline>        dataset,<newline>        batch_size=1,<newline>        shuffle=False,<newline>        sampler=None,<newline>        batch_sampler=None,<newline>        num_workers=None,<newline>        drop_last=False,<newline>        timeout=0,<newline>        worker_init_fn=None,<newline>    ):<newline>        # in certain cases, multi-CPU data loading makes no sense and slows<newline>        # everything down. For this reason, we detect if a dataset is in-memory:<newline>        # if so, num_workers is set to 0 for faster processing<newline>        flair_dataset = dataset<newline>        while True:<newline>            if type(flair_dataset) is Subset:<newline>                flair_dataset = flair_dataset.dataset<newline>            elif type(flair_dataset) is ConcatDataset:<newline>                flair_dataset = flair_dataset.datasets[0]<newline>            else:<newline>                break
62	adjudicated	label-na	"class FlairDatapointDataset(FlairDataset, Generic[DT]):<newline>    """"""<newline>    A simple Dataset object to wrap a List of Datapoints, for example Sentences<newline>    """""""
63	adjudicated	label-na	"class SentenceDataset(FlairDatapointDataset):<newline>    @deprecated(version=""0.11"", reason=""The 'SentenceDataset' class was renamed to 'FlairDatapointDataset'"")<newline>    def __init__(self, sentences: Union[Sentence, List[Sentence]]):<newline>        super().__init__(sentences)"
64	adjudicated	label-na	"class ModelArguments:<newline>    model_name_or_path: str = field(<newline>        metadata={""help"": ""The model checkpoint for weights initialization.""},<newline>    )<newline>    layers: str = field(default=""-1"", metadata={""help"": ""Layers to be fine-tuned.""})<newline>    subtoken_pooling: str = field(<newline>        default=""first"",<newline>        metadata={""help"": ""Subtoken pooling strategy used for fine-tuned.""},<newline>    )<newline>    hidden_size: int = field(default=256, metadata={""help"": ""Hidden size for NER model.""})<newline>    use_crf: bool = field(default=False, metadata={""help"": ""Whether to use a CRF on-top or not.""})"
65	adjudicated	label-na	"class TrainingArguments:<newline>    num_epochs: int = field(default=10, metadata={""help"": ""The number of training epochs.""})<newline>    batch_size: int = field(default=8, metadata={""help"": ""Batch size used for training.""})<newline>    mini_batch_chunk_size: int = field(<newline>        default=1,<newline>        metadata={""help"": ""If smaller than batch size, batches will be chunked.""},<newline>    )<newline>    learning_rate: float = field(default=5e-05, metadata={""help"": ""Learning rate""})<newline>    seed: int = field(default=42, metadata={""help"": ""Seed used for reproducible fine-tuning results.""})<newline>    device: str = field(default=""cuda:0"", metadata={""help"": ""CUDA device string.""})<newline>    weight_decay: float = field(default=0.0, metadata={""help"": ""Weight decay for optimizer.""})<newline>    embeddings_storage_mode: str = field(default=""none"", metadata={""help"": ""Defines embedding storage method.""})"
66	adjudicated	label-na	"class FlertArguments:<newline>    context_size: int = field(default=0, metadata={""help"": ""Context size when using FLERT approach.""})<newline>    respect_document_boundaries: bool = field(<newline>        default=False,<newline>        metadata={""help"": ""Whether to respect document boundaries or not when using FLERT.""},<newline>    )"
67	adjudicated	label-na	"class DataArguments:<newline>    dataset_name: str = field(metadata={""help"": ""Flair NER dataset name.""})<newline>    dataset_arguments: str = field(default="""", metadata={""help"": ""Dataset arguments for Flair NER dataset.""})<newline>    output_dir: str = field(<newline>        default=""resources/taggers/ner"",<newline>        metadata={""help"": ""Defines output directory for final fine-tuned model.""},<newline>    )"
68	adjudicated	label-na	def get_flair_corpus(data_args):<newline>    ner_task_mapping = {}
69	adjudicated	label-na	"class Dictionary:<newline>    """"""<newline>    This class holds a dictionary that maps strings to IDs, used to generate one-hot encodings of strings.<newline>    """""""
70	adjudicated	label-na	"class Label:<newline>    """"""<newline>    This class represents a label. Each label has a value and optionally a confidence score. The<newline>    score needs to be between 0.0 and 1.0. Default value for the score is 1.0.<newline>    """""""
71	adjudicated	label-na	"class DataPoint:<newline>    """"""<newline>    This is the parent class of all data points in Flair (including Token, Sentence, Image, etc.). Each DataPoint<newline>    must be embeddable (hence the abstract property embedding() and methods to() and clear_embeddings()). Also,<newline>    each DataPoint may have Labels in several layers of annotation (hence the functions add_label(), get_labels()<newline>    and the property 'label')<newline>    """""""
72	adjudicated	label-na	"def setup(app: Sphinx) -> None:<newline>    app.add_object_type(<newline>        ""confval"",<newline>        ""confval"",<newline>        objname=""configuration value"",<newline>        indextemplate=""pair: %s; configuration value"",<newline>        doc_field_types=[<newline>            Field(""type"", label=""Type"", has_arg=False, names=(""type"",)),<newline>            Field(""default"", label=""Default"", has_arg=False, names=(""default"",)),<newline>        ],<newline>    )"
73	adjudicated	label-na	def make_cache(input_dir: str, sqlite: bool) -> MetadataStore:<newline>    if sqlite:<newline>        return SqliteMetadataStore(input_dir)<newline>    else:<newline>        return FilesystemMetadataStore(input_dir)
74	adjudicated	label-na	def apply_diff(cache_dir: str, diff_file: str, sqlite: bool = False) -> None:<newline>    cache = make_cache(cache_dir, sqlite)<newline>    with open(diff_file) as f:<newline>        diff = json.load(f)
75	adjudicated	label-na	"def main() -> None:<newline>    parser = argparse.ArgumentParser()<newline>    parser.add_argument(""--sqlite"", action=""store_true"", default=False, help=""Use a sqlite cache"")<newline>    parser.add_argument(""cache_dir"", help=""Directory for the cache"")<newline>    parser.add_argument(""diff"", help=""Cache diff file"")<newline>    args = parser.parse_args()"
76	adjudicated	label-na	class CacheData:<newline>    def __init__(<newline>        self,<newline>        filename: str,<newline>        data_json: JsonDict,<newline>        meta_json: JsonDict,<newline>        data_size: int,<newline>        meta_size: int,<newline>    ) -> None:<newline>        self.filename = filename<newline>        self.data = data_json<newline>        self.meta = meta_json<newline>        self.data_size = data_size<newline>        self.meta_size = meta_size
77	adjudicated	label-na	def total_size(self) -> int:<newline>    return self.data_size + self.meta_size
78	adjudicated	label-na	def extract_classes(chunks: Iterable[CacheData]) -> Iterable[JsonDict]:<newline>    def extract(chunks: Iterable[JsonDict]) -> Iterable[JsonDict]:<newline>        for chunk in chunks:<newline>            if isinstance(chunk, dict):<newline>                yield chunk<newline>                yield from extract(chunk.values())<newline>            elif isinstance(chunk, list):<newline>                yield from extract(chunk)
79	adjudicated	label-na	def extract(chunks: Iterable[JsonDict]) -> Iterable[JsonDict]:<newline>    for chunk in chunks:<newline>        if isinstance(chunk, dict):<newline>            yield chunk<newline>            yield from extract(chunk.values())<newline>        elif isinstance(chunk, list):<newline>            yield from extract(chunk)
80	adjudicated	label-na	class It(Iterator[str]):<newline>    stop = False
81	adjudicated	label-na	"class Aw(Awaitable[int]):<newline>    def __await__(self) -> Generator[str, Any, int]:<newline>        yield ""a""<newline>        return 1"
82	adjudicated	label-na	"def plain_generator() -> Generator[str, None, int]:<newline>    yield ""a""<newline>    return 1"
83	adjudicated	label-na	async def plain_coroutine() -> int:<newline>    return 1
84	adjudicated	label-na	"def decorated_generator() -> Generator[str, None, int]:<newline>    yield ""a""<newline>    return 1"
85	adjudicated	label-na	"def main() -> None:<newline>    parser = argparse.ArgumentParser()<newline>    parser.add_argument(<newline>        ""--to-sqlite"",<newline>        action=""store_true"",<newline>        default=False,<newline>        help=""Convert to a sqlite cache (default: convert from)"",<newline>    )<newline>    parser.add_argument(<newline>        ""--output_dir"",<newline>        action=""store"",<newline>        default=None,<newline>        help=""Output cache location (default: same as input)"",<newline>    )<newline>    parser.add_argument(""input_dir"", help=""Input directory for the cache"")<newline>    args = parser.parse_args()"
86	adjudicated	label-na	def pytest_configure(config):<newline>    mypy_source_root = os.path.dirname(os.path.abspath(__file__))<newline>    if os.getcwd() != mypy_source_root:<newline>        os.chdir(mypy_source_root)
87	adjudicated	label-na	"def pytest_addoption(parser) -> None:<newline>    parser.addoption(<newline>        ""--bench"", action=""store_true"", default=False, help=""Enable the benchmark test runs""<newline>    )"
88	adjudicated	label-na	"def parse_commit_title(diff: str) -> str:<newline>    m = re.search(""\n    ([^ ].*)"", diff)<newline>    assert m is not None, ""Could not parse diff""<newline>    return m.group(1)"
89	adjudicated	label-na	"def main() -> None:<newline>    parser = argparse.ArgumentParser()<newline>    parser.add_argument(<newline>        ""--typeshed-dir"", help=""location of typeshed"", metavar=""dir"", required=True<newline>    )<newline>    parser.add_argument(""commit"", help=""typeshed commit hash to cherry-pick"")<newline>    args = parser.parse_args()<newline>    typeshed_dir = args.typeshed_dir<newline>    commit = args.commit"
90	adjudicated	label-na	"def setup(app):<newline>    app.add_css_file(""custom.css"")"
91	adjudicated	label-na	"class PipenvGroup(DYMMixin, Group):<newline>    """"""Custom Group class provides formatted main help"""""""
92	adjudicated	label-na	class State:<newline>    def __init__(self):<newline>        self.index = None<newline>        self.verbose = False<newline>        self.quiet = False<newline>        self.pypi_mirror = None<newline>        self.python = None<newline>        self.site_packages = None<newline>        self.clear = False<newline>        self.system = False<newline>        self.project = Project()<newline>        self.installstate = InstallState()<newline>        self.lockoptions = LockOptions()
93	adjudicated	label-na	class InstallState:<newline>    def __init__(self):<newline>        self.dev = False<newline>        self.pre = False<newline>        self.selective_upgrade = False<newline>        self.keep_outdated = False<newline>        self.skip_lock = False<newline>        self.ignore_pipfile = False<newline>        self.code = False<newline>        self.requirementstxt = None<newline>        self.deploy = False<newline>        self.packages = []<newline>        self.editables = []<newline>        self.extra_pip_args = []<newline>        self.categories = []
94	adjudicated	label-na	class LockOptions:<newline>    def __init__(self):<newline>        self.dev_only = False
95	adjudicated	label-na	def cli(<newline>    ctx,<newline>    state,<newline>    where=False,<newline>    venv=False,<newline>    py=False,<newline>    envs=False,<newline>    rm=False,<newline>    bare=False,<newline>    man=False,<newline>    support=None,<newline>    help=False,<newline>    site_packages=None,<newline>    **kwargs,<newline>):<newline>    from pipenv.patched.pip._vendor import rich<newline>    from pipenv.utils.shell import system_which
96	adjudicated	label-na	"def install(state, **kwargs):<newline>    """"""Installs provided packages and adds them to Pipfile, or (if no packages are given), installs all packages from Pipfile.""""""<newline>    from pipenv.routines.install import do_install<newline>    "
97	adjudicated	label-na	def upgrade(state, **kwargs):<newline>    from pipenv.routines.update import upgrade<newline>    from pipenv.utils.project import ensure_project
98	adjudicated	label-na	"def uninstall(ctx, state, all_dev=False, all=False, **kwargs):<newline>    """"""Uninstalls a provided package and removes it from Pipfile.""""""<newline>    from pipenv.routines.uninstall import do_uninstall"
99	adjudicated	label-na	"def lock(ctx, state, **kwargs):<newline>    """"""Generates Pipfile.lock.""""""<newline>    from pipenv.routines.lock import do_lock<newline>    from pipenv.utils.project import ensure_project"
100	adjudicated	label-na	def determine_pip_install_arguments():<newline>    implicit_pip = True<newline>    implicit_setuptools = False<newline>    implicit_wheel = True
101	adjudicated	label-na	"def monkeypatch_for_cert(tmpdir):<newline>    """"""Patches `pip install` to provide default certificate with the lowest priority.<newline>    """""""
102	adjudicated	label-na	"def cert_parse_args(self, args):<newline>    if not self.parser.get_default_values().cert:<newline>        # There are no user provided cert -- force use of bundled cert<newline>        self.parser.defaults[""cert""] = cert_path  # calculated above<newline>    return install_parse_args(self, args)"
103	adjudicated	label-na	def bootstrap(tmpdir):<newline>    monkeypatch_for_cert(tmpdir)
104	adjudicated	label-na	def map(dataset: datasets.Dataset, **kwargs):<newline>    _ = dataset.map(**kwargs)
105	adjudicated	label-na	def filter(dataset: datasets.Dataset, **kwargs):<newline>    _ = dataset.filter(**kwargs
106	adjudicated	label-na	"def benchmark_map_filter():<newline>    times = {""num examples"": SPEED_TEST_N_EXAMPLES}<newline>    with tempfile.TemporaryDirectory() as tmp_dir:<newline>        features = datasets.Features({""text"": datasets.Value(""string""), ""numbers"": datasets.Value(""float32"")})<newline>        dataset = generate_example_dataset(<newline>            os.path.join(tmp_dir, ""dataset.arrow""), features, num_examples=SPEED_TEST_N_EXAMPLES<newline>        )"
107	adjudicated	label-na	"def tokenize(examples):<newline>    return tokenizer(examples[""text""])"
108	adjudicated	label-na	class RandIter:<newline>    low: int<newline>    high: int<newline>    size: int<newline>    seed: int
109	adjudicated	label-na	"def generate_100B_dataset(num_examples: int, chunk_size: int) -> datasets.Dataset:<newline>    table = pa.Table.from_pydict({""col"": [0] * chunk_size})<newline>    table = pa.concat_tables([table] * (num_examples // chunk_size))<newline>    return datasets.Dataset(table, fingerprint=""table_100B"")"
110	adjudicated	label-na	def __post_init__(self):<newline>    rng = np.random.default_rng(self.seed)<newline>    self._sampled_values = rng.integers(low=self.low, high=self.high, size=self.size).tolist()
111	adjudicated	label-na	def __iter__(self):<newline>    return iter(self._sampled_values)
112	adjudicated	label-na	def __len__(self):<newline>    return self.size
113	adjudicated	label-na	"def format_json_to_md(input_json_file, output_md_file):<newline>    with open(input_json_file, encoding=""utf-8"") as f:<newline>        results = json.load(f)"
114	adjudicated	label-na	def read(dataset: datasets.Dataset, length):<newline>    for i in range(length):<newline>        _ = dataset[i]
115	adjudicated	label-na	def read_batch(dataset: datasets.Dataset, length, batch_size):<newline>    for i in range(0, len(dataset), batch_size):<newline>        _ = dataset[i : i + batch_size]
116	adjudicated	label-na	def read_formatted(dataset: datasets.Dataset, length, type):<newline>    with dataset.formatted_as(type=type):<newline>        for i in range(length):<newline>            _ = dataset[i]
117	adjudicated	label-na	def read_formatted_batch(dataset: datasets.Dataset, length, batch_size, type):<newline>    with dataset.formatted_as(type=type):<newline>        for i in range(0, length, batch_size):<newline>            _ = dataset[i : i + batch_size]
118	adjudicated	label-na	"def benchmark_iterating():<newline>    times = {""num examples"": SPEED_TEST_N_EXAMPLES}<newline>    functions = [<newline>        (read, {""length"": SMALL_TEST}),<newline>        (read, {""length"": SPEED_TEST_N_EXAMPLES}),<newline>        (read_batch, {""length"": SPEED_TEST_N_EXAMPLES, ""batch_size"": 10}),<newline>        (read_batch, {""length"": SPEED_TEST_N_EXAMPLES, ""batch_size"": 100}),<newline>        (read_batch, {""length"": SPEED_TEST_N_EXAMPLES, ""batch_size"": 1_000}),<newline>        (read_formatted, {""type"": ""numpy"", ""length"": SMALL_TEST}),<newline>        (read_formatted, {""type"": ""pandas"", ""length"": SMALL_TEST}),<newline>        (read_formatted, {""type"": ""torch"", ""length"": SMALL_TEST}),<newline>        (read_formatted, {""type"": ""tensorflow"", ""length"": SMALL_TEST}),<newline>        (read_formatted_batch, {""type"": ""numpy"", ""length"": SMALL_TEST, ""batch_size"": 10}),<newline>        (read_formatted_batch, {""type"": ""numpy"", ""length"": SMALL_TEST, ""batch_size"": 1_000}),<newline>    ]"
119	adjudicated	label-na	def get_duration(func):<newline>    def wrapper(*args, **kwargs):<newline>        starttime = timeit.default_timer()<newline>        _ = func(*args, **kwargs)<newline>        delta = timeit.default_timer() - starttime<newline>        return delta
120	adjudicated	label-na	def wrapper(*args, **kwargs):<newline>    starttime = timeit.default_timer()<newline>    _ = func(*args, **kwargs)<newline>    delta = timeit.default_timer() - starttime<newline>    return delta
121	adjudicated	label-na	"def generate_examples(features: dict, num_examples=100, seq_shapes=None):<newline>    dummy_data = []<newline>    seq_shapes = seq_shapes or {}<newline>    for i in range(num_examples):<newline>        example = {}<newline>        for col_id, (k, v) in enumerate(features.items()):<newline>            if isinstance(v, _ArrayXD):<newline>                data = np.random.rand(*v.shape).astype(v.dtype)<newline>            elif isinstance(v, datasets.Value):<newline>                if v.dtype == ""string"":<newline>                    data = ""The small grey turtle was surprisingly fast when challenged.""<newline>                else:<newline>                    data = np.random.randint(10, size=1).astype(v.dtype).item()<newline>            elif isinstance(v, datasets.Sequence):<newline>                while isinstance(v, datasets.Sequence):<newline>                    v = v.feature<newline>                shape = seq_shapes[k]<newline>                data = np.random.rand(*shape).astype(v.dtype)<newline>            example[k] = data"
122	adjudicated	label-na	def generate_example_dataset(dataset_path, features, num_examples=100, seq_shapes=None):<newline>    dummy_data = generate_examples(features, num_examples=num_examples, seq_shapes=seq_shapes)
123	adjudicated	label-na	"def write(my_features, dummy_data, tmp_dir):<newline>    with ArrowWriter(features=my_features, path=os.path.join(tmp_dir, ""beta.arrow"")) as writer:<newline>        for key, record in dummy_data:<newline>            example = my_features.encode_example(record)<newline>            writer.write(example)<newline>        num_examples, num_bytes = writer.finalize()"
124	adjudicated	label-na	"def read_unformated(feats, tmp_dir):<newline>    dataset = datasets.Dataset.from_file(<newline>        filename=os.path.join(tmp_dir, ""beta.arrow""), info=datasets.DatasetInfo(features=feats)<newline>    )<newline>    for _ in dataset:<newline>        pass"
125	adjudicated	label-na	"def read_formatted_as_numpy(feats, tmp_dir):<newline>    dataset = datasets.Dataset.from_file(<newline>        filename=os.path.join(tmp_dir, ""beta.arrow""), info=datasets.DatasetInfo(features=feats)<newline>    )<newline>    dataset.set_format(""numpy"")<newline>    for _ in dataset:<newline>        pass"
126	adjudicated	label-na	"def read_batch_unformated(feats, tmp_dir):<newline>    batch_size = 10<newline>    dataset = datasets.Dataset.from_file(<newline>        filename=os.path.join(tmp_dir, ""beta.arrow""), info=datasets.DatasetInfo(features=feats)<newline>    )<newline>    for i in range(0, len(dataset), batch_size):<newline>        _ = dataset[i : i + batch_size]"
127	adjudicated	label-na	"def read_batch_formatted_as_numpy(feats, tmp_dir):<newline>    batch_size = 10<newline>    dataset = datasets.Dataset.from_file(<newline>        filename=os.path.join(tmp_dir, ""beta.arrow""), info=datasets.DatasetInfo(features=feats)<newline>    )<newline>    dataset.set_format(""numpy"")<newline>    for i in range(0, len(dataset), batch_size):<newline>        _ = dataset[i : i + batch_size]"
128	adjudicated	label-na	def select(dataset: datasets.Dataset):<newline>    _ = dataset.select(range(0, len(dataset), 2))
129	adjudicated	label-na	"def sort(dataset: datasets.Dataset):<newline>    _ = dataset.sort(""numbers"")"
130	adjudicated	label-na	def shuffle(dataset: datasets.Dataset):<newline>    _ = dataset.shuffle()
131	adjudicated	label-na	def train_test_split(dataset: datasets.Dataset):<newline>    _ = dataset.train_test_split(0.1)
132	adjudicated	label-na	def shard(dataset: datasets.Dataset, num_shards=10):<newline>    for shard_id in range(num_shards):<newline>        _ = dataset.shard(num_shards, shard_id)
133	adjudicated	label-na	"class RegexpChunkApp:<newline>    """"""<newline>    A graphical tool for exploring the regular expression based chunk<newline>    parser ``nltk.chunk.RegexpChunkParser``.<newline>    """""""
134	adjudicated	label-na	"def normalize_grammar(self, grammar):<newline>    # Strip comments<newline>    grammar = re.sub(r""((\\.|[^#])*)(#.*)?"", r""\1"", grammar)<newline>    # Normalize whitespace<newline>    grammar = re.sub("" +"", "" "", grammar)<newline>    grammar = re.sub(r""\n\s+"", r""\n"", grammar)<newline>    grammar = grammar.strip()<newline>    # [xx] Hack: automatically backslash $!<newline>    grammar = re.sub(r""([^\\])\$"", r""\1\\$"", grammar)<newline>    return grammar"
135	adjudicated	label-na	"def _init_bindings(self, top):<newline>    top.bind(""<Control-n>"", self._devset_next)<newline>    top.bind(""<Control-p>"", self._devset_prev)<newline>    top.bind(""<Control-t>"", self.toggle_show_trace)<newline>    top.bind(""<KeyPress>"", self.update)<newline>    top.bind(""<Control-s>"", lambda e: self.save_grammar())<newline>    top.bind(""<Control-o>"", lambda e: self.load_grammar())<newline>    self.grammarbox.bind(""<Control-t>"", self.toggle_show_trace)<newline>    self.grammarbox.bind(""<Control-n>"", self._devset_next)<newline>    self.grammarbox.bind(""<Control-p>"", self._devset_prev)"
136	adjudicated	label-na	"def _init_fonts(self, top):<newline>    # TWhat's our font size (default=same as sysfont)<newline>    self._size = IntVar(top)<newline>    self._size.set(20)<newline>    self._font = Font(family=""helvetica"", size=-self._size.get())<newline>    self._smallfont = Font(<newline>        family=""helvetica"", size=-(int(self._size.get() * 14 // 20))<newline>    )"
137	adjudicated	label-na	"class RecursiveDescentApp:<newline>    """"""<newline>    A graphical tool for exploring the recursive descent parser.  The tool<newline>    displays the parser's tree and the remaining text, and allows the<newline>    user to control the parser's operation.  In particular, the user<newline>    can expand subtrees on the frontier, match tokens on the frontier<newline>    against the text, and backtrack.  A ""step"" button simply steps<newline>    through the parsing process, performing the operations that<newline>    ``RecursiveDescentParser`` would use.<newline>    """"""<newline><newline>    def __init__(self, grammar, sent, trace=0):<newline>        self._sent = sent<newline>        self._parser = SteppingRecursiveDescentParser(grammar, trace)<newline><newline>"
138	adjudicated	label-na	def __init__(self, grammar, sent, trace=0):<newline>    self._sent = sent<newline>    self._parser = SteppingRecursiveDescentParser(grammar, trace)
139	adjudicated	label-na	"def _init_fonts(self, root):<newline>    # See: <http://www.astro.washington.edu/owen/ROTKFolklore.html><newline>    self._sysfont = Font(font=Button()[""font""])<newline>    root.option_add(""*Font"", self._sysfont)"
140	adjudicated	label-na	"def _init_bindings(self):<newline>    # Key bindings are a good thing.<newline>    self._top.bind(""<Control-q>"", self.destroy)<newline>    self._top.bind(""<Control-x>"", self.destroy)<newline>    self._top.bind(""<Escape>"", self.destroy)<newline>    self._top.bind(""e"", self.expand)<newline>    # self._top.bind('<Alt-e>', self.expand)<newline>    # self._top.bind('<Control-e>', self.expand)<newline>    self._top.bind(""m"", self.match)<newline>    self._top.bind(""<Alt-m>"", self.match)<newline>    self._top.bind(""<Control-m>"", self.match)<newline>    self._top.bind(""b"", self.backtrack)<newline>    self._top.bind(""<Alt-b>"", self.backtrack)<newline>    self._top.bind(""<Control-b>"", self.backtrack)<newline>    self._top.bind(""<Control-z>"", self.backtrack)<newline>    self._top.bind(""<BackSpace>"", self.backtrack)<newline>    self._top.bind(""a"", self.autostep)<newline>    # self._top.bind('<Control-a>', self.autostep)<newline>    self._top.bind(""<Control-space>"", self.autostep)<newline>    self._top.bind(""<Control-c>"", self.cancel_autostep)<newline>    self._top.bind(""<space>"", self.step)<newline>    self._top.bind(""<Delete>"", self.reset)<newline>    self._top.bind(""<Control-p>"", self.postscript)<newline>    # self._top.bind('<h>', self.help)<newline>    # self._top.bind('<Alt-h>', self.help)<newline>    self._top.bind(""<Control-h>"", self.help)<newline>    self._top.bind(""<F1>"", self.help)<newline>    # self._top.bind('<g>', self.toggle_grammar)<newline>    # self._top.bind('<Alt-g>', self.toggle_grammar)<newline>    # self._top.bind('<Control-g>', self.toggle_grammar)<newline>    self._top.bind(""<Control-g>"", self.edit_grammar)<newline>    self._top.bind(""<Control-t>"", self.edit_sentence)"
141	adjudicated	label-na	"class ConcordanceSearchView:<newline>    _BACKGROUND_COLOUR = ""#FFF""  # white"
142	adjudicated	label-na	class ConcordanceSearchModel:<newline>    def __init__(self, queue):<newline>        self.queue = queue<newline>        self.CORPORA = _CORPORA<newline>        self.DEFAULT_CORPUS = _DEFAULT<newline>        self.selected_corpus = None<newline>        self.reset_query()<newline>        self.reset_results()<newline>        self.result_count = None<newline>        self.last_sent_searched = 0
143	adjudicated	label-na	class LoadCorpus(threading.Thread):<newline>    def __init__(self, name, model):<newline>        threading.Thread.__init__(self)<newline>        self.model, self.name = model, name
144	adjudicated	label-na	class SearchCorpus(threading.Thread):<newline>    def __init__(self, model, page, count):<newline>        self.model, self.count, self.page = model, count, page<newline>        threading.Thread.__init__(self)
145	adjudicated	label-na	"class Zone:<newline>    def __init__(self, image, initialField, initialText):<newline>        frm = Frame(root)<newline>        frm.config(background=""white"")<newline>        self.image = PhotoImage(format=""gif"", data=images[image.upper()])<newline>        self.imageDimmed = PhotoImage(format=""gif"", data=images[image])<newline>        self.img = Label(frm)<newline>        self.img.config(borderwidth=0)<newline>        self.img.pack(side=""left"")<newline>        self.fld = Text(frm, **fieldParams)<newline>        self.initScrollText(frm, self.fld, initialField)<newline>        frm = Frame(root)<newline>        self.txt = Text(frm, **textParams)<newline>        self.initScrollText(frm, self.txt, initialText)<newline>        for i in range(2):<newline>            self.txt.tag_config(colors[i], background=colors[i])<newline>            self.txt.tag_config(""emph"" + colors[i], foreground=emphColors[i])"
146	adjudicated	label-na	"class FindZone(Zone):<newline>    def addTags(self, m):<newline>        color = next(self.colorCycle)<newline>        self.txt.tag_add(color, ""1.0+%sc"" % m.start(), ""1.0+%sc"" % m.end())<newline>        try:<newline>            self.txt.tag_add(<newline>                ""emph"" + color, ""1.0+%sc"" % m.start(""emph""), ""1.0+%sc"" % m.end(""emph"")<newline>            )<newline>        except:<newline>            pass"
147	adjudicated	label-na	"class ReplaceZone(Zone):<newline>    def addTags(self, m):<newline>        s = sz.rex.sub(self.repl, m.group())<newline>        self.txt.delete(<newline>            ""1.0+%sc"" % (m.start() + self.diff), ""1.0+%sc"" % (m.end() + self.diff)<newline>        )<newline>        self.txt.insert(""1.0+%sc"" % (m.start() + self.diff), s, next(self.colorCycle))<newline>        self.diff += len(s) - (m.end() - m.start())"
148	adjudicated	label-na	"def __init__(self, image, initialField, initialText):<newline>    frm = Frame(root)<newline>    frm.config(background=""white"")<newline>    self.image = PhotoImage(format=""gif"", data=images[image.upper()])<newline>    self.imageDimmed = PhotoImage(format=""gif"", data=images[image])<newline>    self.img = Label(frm)<newline>    self.img.config(borderwidth=0)<newline>    self.img.pack(side=""left"")<newline>    self.fld = Text(frm, **fieldParams)<newline>    self.initScrollText(frm, self.fld, initialField)<newline>    frm = Frame(root)<newline>    self.txt = Text(frm, **textParams)<newline>    self.initScrollText(frm, self.txt, initialText)<newline>    for i in range(2):<newline>        self.txt.tag_config(colors[i], background=colors[i])<newline>        self.txt.tag_config(""emph"" + colors[i], foreground=emphColors[i])"
149	adjudicated	label-na	"def initScrollText(self, frm, txt, contents):<newline>    scl = Scrollbar(frm)<newline>    scl.config(command=txt.yview)<newline>    scl.pack(side=""right"", fill=""y"")<newline>    txt.pack(side=""left"", expand=True, fill=""x"")<newline>    txt.config(yscrollcommand=scl.set)<newline>    txt.insert(""1.0"", contents)<newline>    frm.pack(fill=""x"")<newline>    Frame(height=2, bd=1, relief=""ridge"").pack(fill=""x"")"
150	adjudicated	label-na	"class CollocationsView:<newline>    _BACKGROUND_COLOUR = ""#FFF""  # white"
151	adjudicated	label-na	class CollocationsModel:<newline>    def __init__(self, queue):<newline>        self.result_count = None<newline>        self.selected_corpus = None<newline>        self.collocations = None<newline>        self.CORPORA = _CORPORA<newline>        self.DEFAULT_CORPUS = _DEFAULT<newline>        self.queue = queue<newline>        self.reset_results()
152	adjudicated	label-na	class LoadCorpus(threading.Thread):<newline>    def __init__(self, name, model):<newline>        threading.Thread.__init__(self)<newline>        self.model, self.name = model, name
153	adjudicated	label-na	def __init__(self):<newline>    self.queue = q.Queue()<newline>    self.model = CollocationsModel(self.queue)<newline>    self.top = Tk()<newline>    self._init_top(self.top)<newline>    self._init_menubar()<newline>    self._init_widgets(self.top)<newline>    self.load_corpus(self.model.DEFAULT_CORPUS)<newline>    self.after = self.top.after(POLL_INTERVAL, self._poll)
154	adjudicated	label-na	"class EdgeList(ColorizedList):<newline>    ARROW = SymbolWidget.SYMBOLS[""rightarrow""]"
155	adjudicated	label-na	"class ChartMatrixView:<newline>    """"""<newline>    A view of a chart that displays the contents of the corresponding matrix.<newline>    """""""
156	adjudicated	label-na	class ChartResultsView:<newline>    def __init__(self, parent, chart, grammar, toplevel=True):<newline>        self._chart = chart<newline>        self._grammar = grammar<newline>        self._trees = []<newline>        self._y = 10<newline>        self._treewidgets = []<newline>        self._selection = None<newline>        self._selectbox = None
157	adjudicated	label-na	"class ChartView:<newline>    """"""<newline>    A component for viewing charts.  This is used by ``ChartParserApp`` to<newline>    allow students to interactively experiment with various chart<newline>    parsing techniques.  It is also used by ``Chart.draw()``.<newline>    """""""
158	adjudicated	label-na	"def _fake_PIPE(*args, **kwargs):<newline>    raise NotImplementedError(""subprocess.PIPE is not supported."")"
159	adjudicated	label-na	"def _fake_Popen(*args, **kwargs):<newline>    raise NotImplementedError(""subprocess.Popen is not supported."")"
160	adjudicated	label-na	"def demo():<newline>    print(""To run the demo code for a module, type nltk.module.demo()"")"
161	adjudicated	label-na	"def make_parser():<newline>    parser = argparse.ArgumentParser()<newline>    parser.add_argument(<newline>        ""--deprecation"",<newline>        choices=[""all"", ""pending"", ""imminent"", ""none""],<newline>        default=""imminent"",<newline>    )<newline>    parser.add_argument(""--postgres"", action=""store_true"")<newline>    parser.add_argument(""--elasticsearch5"", action=""store_true"")<newline>    parser.add_argument(""--elasticsearch6"", action=""store_true"")<newline>    parser.add_argument(""--elasticsearch7"", action=""store_true"")<newline>    parser.add_argument(""--emailuser"", action=""store_true"")<newline>    parser.add_argument(""--disabletimezone"", action=""store_true"")<newline>    parser.add_argument(""--bench"", action=""store_true"")<newline>    return parser"
162	adjudicated	label-na	def parse_args(args=None):<newline>    return make_parser().parse_known_args(args)
163	adjudicated	label-na	def runtests():<newline>    args, rest = parse_args()
164	adjudicated	label-na	"def pytest_addoption(parser):<newline>    parser.addoption(<newline>        ""--deprecation"",<newline>        choices=[""all"", ""pending"", ""imminent"", ""none""],<newline>        default=""pending"",<newline>    )<newline>    parser.addoption(""--postgres"", action=""store_true"")<newline>    parser.addoption(""--elasticsearch"", action=""store_true"")"
165	adjudicated	label-na	"def pytest_configure(config):<newline>    deprecation = config.getoption(""deprecation"")"
166	adjudicated	label-na	def pytest_unconfigure(config):<newline>    from wagtail.test.settings import MEDIA_ROOT, STATIC_ROOT
167	adjudicated	label-na	def get_language_name(locale_string):<newline>    try:<newline>        return LANGUAGE_OVERRIDES[locale_string]<newline>    except KeyError:<newline>        return Locale.parse(locale_string).english_name
168	adjudicated	label-na	"def setup(app):<newline>    app.add_js_file(""js/banner.js"")"
169	adjudicated	label-na	"def __init__(self, environment):<newline>    """"""Initialize the extension with the given environment.""""""<newline>    super().__init__(environment)"
170	adjudicated	label-na	"def _expand_path(path):<newline>    """"""Expand both environment variables and user home in the given path.""""""<newline>    path = os.path.expandvars(path)<newline>    path = os.path.expanduser(path)<newline>    return path"
171	adjudicated	label-na	"def merge_configs(default, overwrite):<newline>    """"""Recursively update a dict with the key/value pair of another.<newline><newline>    def get_config(config_path):<newline>    """"""Retrieve the config from the specified path, returning a config dict.""""""<newline>    if not os.path.exists(config_path):<newline>        raise ConfigDoesNotExistException(f'Config file {config_path} does not exist.')"
172	adjudicated	label-na	"def get_config(config_path):<newline>    """"""Retrieve the config from the specified path, returning a config dict.""""""<newline>    if not os.path.exists(config_path):<newline>        raise ConfigDoesNotExistException(f'Config file {config_path} does not exist.')"
173	adjudicated	label-na	"class ConfigDoesNotExistException(CookiecutterException):<newline>    """"""<newline>    Exception for missing config file.<newline>    """""""
174	adjudicated	label-na	"def version_msg():<newline>    """"""Return the Cookiecutter version, location and Python powering it.""""""<newline>    python_version = sys.version<newline>    location = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))<newline>    return f""Cookiecutter {__version__} from {location} (Python {python_version})"""
175	adjudicated	label-na	"def validate_extra_context(ctx, param, value):<newline>    """"""Validate extra context.""""""<newline>    for string in value:<newline>        if '=' not in string:<newline>            raise click.BadParameter(<newline>                f""EXTRA_CONTEXT should contain items of the form key=value; ""<newline>                f""'{string}' doesn't match that form""<newline>            )"
176	adjudicated	label-na	"def list_installed_templates(default_config, passed_config_file):<newline>    """"""List installed (locally cloned) templates. Use cookiecutter --list-installed.""""""<newline>    config = get_user_config(passed_config_file, default_config)<newline>    cookiecutter_folder = config.get('cookiecutters_dir')<newline>    if not os.path.exists(cookiecutter_folder):<newline>        click.echo(<newline>            f""Error: Cannot list installed templates. ""<newline>            f""Folder does not exist: {cookiecutter_folder}""<newline>        )<newline>        sys.exit(-1)"
177	adjudicated	label-na	"def main(<newline>    template,<newline>    extra_context,<newline>    no_input,<newline>    checkout,<newline>    verbose,<newline>    replay,<newline>    overwrite_if_exists,<newline>    output_dir,<newline>    config_file,<newline>    default_config,<newline>    debug_file,<newline>    directory,<newline>    skip_if_file_exists,<newline>    accept_hooks,<newline>    replay_file,<newline>    list_installed,<newline>    keep_project_on_failure,<newline>):<newline>    """"""Create a project from a Cookiecutter project template (TEMPLATE)."
178	adjudicated	label-na	"def load_response(url: str, filename: str) -> HtmlResponse:<newline>    input_path = Path(__file__).parent / ""_tests"" / filename<newline>    return HtmlResponse(url, body=input_path.read_bytes())"
179	adjudicated	label-na	"def setup(namespace):<newline>    namespace[""load_response""] = load_response"
180	adjudicated	label-na	class settingslist_node(nodes.General, nodes.Element):<newline>    pass
181	adjudicated	label-na	"class SettingsListDirective(Directive):<newline>    def run(self):<newline>        return [settingslist_node("""")]"
182	adjudicated	label-na	"def is_setting_index(node):<newline>    if node.tagname == ""index"" and node[""entries""]:<newline>        # index entries for setting directives look like:<newline>        # [('pair', 'SETTING_NAME; setting', 'std:setting-SETTING_NAME', '')]<newline>        entry_type, info, refid = node[""entries""][0][:3]<newline>        return entry_type == ""pair"" and info.endswith(""; setting"")<newline>    return False"
183	adjudicated	label-na	def get_setting_target(node):<newline>    # target nodes are placed next to the node in the doc tree<newline>    return node.parent[node.parent.index(node) + 1]
184	adjudicated	label-na	"def setup(app):<newline>    app.connect(""autodoc-skip-member"", maybe_skip_member)"
185	adjudicated	label-na	"def maybe_skip_member(app, what, name, obj, skip, options):<newline>    if not skip:<newline>        # autodocs was generating a text ""alias of"" for the following members<newline>        # https://github.com/sphinx-doc/sphinx/issues/4422<newline>        return name in {""default_item_class"", ""default_selector_class""}<newline>    return skip"
186	adjudicated	label-na	def main():<newline>    # Used for remembering the file (and its contents)<newline>    # so we don't have to open the same file again.<newline>    _filename = None<newline>    _contents = None
187	adjudicated	label-na	"class QPSSpider(Spider):<newline>    name = ""qps""<newline>    benchurl = ""http://localhost:8880/"""
188	adjudicated	label-na	def __init__(self, *a, **kw):<newline>    super().__init__(*a, **kw)<newline>    if self.qps is not None:<newline>        self.qps = float(self.qps)<newline>        self.download_delay = 1 / self.qps<newline>    elif self.download_delay is not None:<newline>        self.download_delay = float(self.download_delay)
189	adjudicated	label-na	"def start_requests(self):<newline>    url = self.benchurl<newline>    if self.latency is not None:<newline>        url += f""?latency={self.latency}"""
190	adjudicated	label-na	def parse(self, response):<newline>    pass
191	adjudicated	label-na	"def _py_files(folder):<newline>    return (str(p) for p in Path(folder).rglob(""*.py""))"
192	adjudicated	label-na	"def chdir(tmpdir):<newline>    """"""Change to pytest-provided temporary directory""""""<newline>    tmpdir.chdir()"
193	adjudicated	label-na	"def pytest_addoption(parser):<newline>    parser.addoption(<newline>        ""--reactor"",<newline>        default=""default"",<newline>        choices=[""default"", ""asyncio""],<newline>    )"
194	adjudicated	label-na	class Root(Resource):<newline>    def __init__(self):<newline>        Resource.__init__(self)<newline>        self.concurrent = 0<newline>        self.tail = deque(maxlen=100)<newline>        self._reset_stats()
195	adjudicated	label-na	def __init__(self):<newline>    Resource.__init__(self)<newline>    self.concurrent = 0<newline>    self.tail = deque(maxlen=100)<newline>    self._reset_stats()
196	adjudicated	label-na	def _reset_stats(self):<newline>    self.tail.clear()<newline>    self.start = self.lastmark = self.lasttime = time()
197	adjudicated	label-na	def getChild(self, request, name):<newline>    return self
198	adjudicated	label-na	def render(self, request):<newline>    now = time()<newline>    delta = now - self.lasttime
199	adjudicated	label-na	def test_dtw(N: int, M: int):<newline>    steps = np.concatenate([np.zeros(N - 1), np.ones(M - 1)])<newline>    np.random.shuffle(steps)<newline>    x = np.random.random((N, M)).astype(np.float32)
200	adjudicated	label-na	def test_dtw_cuda_equivalence(N: int, M: int):<newline>    x_numpy = np.random.randn(N, M).astype(np.float32)<newline>    x_cuda = torch.from_numpy(x_numpy).cuda()
201	adjudicated	label-na	def test_median_filter(shape):<newline>    x = torch.randn(*shape)
202	adjudicated	label-na	def test_median_filter_equivalence(shape):<newline>    x = torch.randn(*shape)
203	adjudicated	label-na	"def test_number_normalizer(std):<newline>    assert std(""two"") == ""2""<newline>    assert std(""thirty one"") == ""31""<newline>    assert std(""five twenty four"") == ""524""<newline>    assert std(""nineteen ninety nine"") == ""1999""<newline>    assert std(""twenty nineteen"") == ""2019"""
204	adjudicated	label-na	def test_spelling_normalizer():<newline>    std = EnglishSpellingNormalizer()
205	adjudicated	label-na	"def test_text_normalizer():<newline>    std = EnglishTextNormalizer()<newline>    assert std(""Let's"") == ""let us""<newline>    assert std(""he's like"") == ""he is like""<newline>    assert std(""she's been like"") == ""she has been like""<newline>    assert std(""10km"") == ""10 km""<newline>    assert std(""10mm"") == ""10 mm""<newline>    assert std(""RC232"") == ""rc 232"""
206	adjudicated	label-na	"def test_audio():<newline>    audio_path = os.path.join(os.path.dirname(__file__), ""jfk.flac"")<newline>    audio = load_audio(audio_path)<newline>    assert audio.ndim == 1<newline>    assert SAMPLE_RATE * 10 < audio.shape[0] < SAMPLE_RATE * 12<newline>    assert 0 < audio.std() < 1"
207	adjudicated	label-na	"def pytest_configure(config):<newline>    config.addinivalue_line(""markers"", ""requires_cuda"")"
208	adjudicated	label-na	def random():<newline>    rand.seed(42)<newline>    numpy.random.seed(42)
209	adjudicated	label-na	"def test_transcribe(model_name: str):<newline>    device = ""cuda"" if torch.cuda.is_available() else ""cpu""<newline>    model = whisper.load_model(model_name).to(device)<newline>    audio_path = os.path.join(os.path.dirname(__file__), ""jfk.flac"")"
210	adjudicated	label-na	def test_tokenizer():<newline>    gpt2_tokenizer = get_tokenizer(multilingual=False)<newline>    multilingual_tokenizer = get_tokenizer(multilingual=True)
211	adjudicated	label-na	def test_split_on_unicode():<newline>    multilingual_tokenizer = get_tokenizer(multilingual=True)
212	adjudicated	label-na	def _download(url: str, root: str, in_memory: bool) -> Union[bytes, str]:<newline>    os.makedirs(root, exist_ok=True)
213	adjudicated	label-na	"def available_models() -> List[str]:<newline>    """"""Returns the names of available models""""""<newline>    return list(_MODELS.keys())"
214	adjudicated	label-na	"def load_model(<newline>    name: str,<newline>    device: Optional[Union[str, torch.device]] = None,<newline>    download_root: str = None,<newline>    in_memory: bool = False,<newline>) -> Whisper:<newline>    """"""<newline>    Load a Whisper ASR model"
215	adjudicated	label-na	class _Undefined:<newline>    def __repr__(self) -> str:<newline>        return 'see-below'
216	adjudicated	label-na	"class Snowflake(Protocol):<newline>    """"""An ABC that details the common operations on a Discord model.<newline>    """""""
217	adjudicated	label-na	"class User(Snowflake, Protocol):<newline>    """"""An ABC that details the common operations on a Discord user.<newline>    """""""
218	adjudicated	label-na	"class PrivateChannel:<newline>    """"""An ABC that details the common operations on a private Discord channel.<newline>    """""""
219	adjudicated	label-na	class _Overwrites:<newline>    __slots__ = ('id', 'allow', 'deny', 'type')
220	adjudicated	label-na	"class VersionInfo(NamedTuple):<newline>    major: int<newline>    minor: int<newline>    micro: int<newline>    releaselevel: Literal[""alpha"", ""beta"", ""candidate"", ""final""]<newline>    serial: int"
221	adjudicated	label-na	class Bot(commands.{base}):<newline>    def __init__(self, intents: discord.Intents, **kwargs):<newline>        super().__init__(command_prefix=commands.when_mentioned_or('{prefix}'), intents=intents, **kwargs)
222	adjudicated	label-na	def show_version() -> None:<newline>    entries = []
223	adjudicated	label-na	def core(parser: argparse.ArgumentParser, args: argparse.Namespace) -> None:<newline>    if args.version:<newline>        show_version()<newline>    else:<newline>        parser.print_help()
224	adjudicated	label-na	"class Parameter:<newline>    """"""A class that contains the parameter information of a :class:`Command` callback.<newline>    """""""
225	adjudicated	label-na	"class ContextMenu:<newline>    """"""A class that implements a context menu application command.<newline>    """""""
226	adjudicated	label-na	"class BaseActivity:<newline>    """"""The base activity that all user-settable activities inherit from.<newline>    A user-settable activity is one that can be used in :meth:`Client.change_presence`.<newline>    """""""
227	adjudicated	label-na	"class Activity(BaseActivity):<newline>    """"""Represents an activity in Discord.<newline>    """""""
228	adjudicated	label-na	"class Game(BaseActivity):<newline>    """"""A slimmed down version of :class:`Activity` that represents a Discord game.<newline>    """""""
229	adjudicated	label-na	"class Streaming(BaseActivity):<newline>    """"""A slimmed down version of :class:`Activity` that represents a Discord streaming status.<newline>    """""""
230	adjudicated	label-na	"class Spotify:<newline>    """"""Represents a Spotify listening activity from Discord. This is a special case of<newline>    :class:`Activity` that makes it easier to work with the Spotify integration.<newline>    """""""
231	adjudicated	label-na	"class Cooldown:<newline>    """"""Represents a cooldown for a command.<newline>    """""""
232	adjudicated	label-na	def __init__(self, rate: float, per: float) -> None:<newline>    self.rate: int = int(rate)<newline>    self.per: float = float(per)<newline>    self._window: float = 0.0<newline>    self._tokens: int = self.rate<newline>    self._last: float = 0.0
233	adjudicated	label-na	"def get_tokens(self, current: Optional[float] = None) -> int:<newline>    """"""Returns the number of available tokens before rate limiting is applied.<newline>    """""""
234	adjudicated	label-na	"def get_retry_after(self, current: Optional[float] = None) -> float:<newline>    """"""Returns the time in seconds until the cooldown will be reset.<newline>    """""""
235	adjudicated	label-na	"def update_rate_limit(self, current: Optional[float] = None, *, tokens: int = 1) -> Optional[float]:<newline>    """"""Updates the cooldown rate limit.<newline>    """""""
236	adjudicated	label-na	def close_api_gracefully(apis):<newline>    try:<newline>        for api in apis.values():<newline>            process = api['process']<newline>            childs = get_child_pids(process.pid)<newline>            for p in childs:<newline>                try:<newline>                    os.kill(p, signal.SIGTERM)<newline>                except Exception:<newline>                    p.kill()<newline>            sys.stdout.flush()<newline>            process.terminate()<newline>            process.join()<newline>            sys.stdout.flush()<newline>    except KeyboardInterrupt:<newline>        sys.exit(0)<newline>    except psutil.NoSuchProcess:<newline>        pass
237	adjudicated	label-na	async def wait_api_start(api_name, pid, port):<newline>    timeout = 60<newline>    start_time = time.time()<newline>    started = is_pid_listen_port(pid, port)<newline>    while (time.time() - start_time) < timeout and started is False:<newline>        await asyncio.sleep(0.5)<newline>        started = is_pid_listen_port(pid, port)<newline>    return api_name, port, started
238	adjudicated	label-na	"async def wait_apis_start():<newline>    futures = [<newline>        wait_api_start(api_name, api_data['process'].pid, api_data['port'])<newline>        for api_name, api_data in apis.items() if 'port' in api_data<newline>    ]<newline>    for i, future in enumerate(asyncio.as_completed(futures)):<newline>        api_name, port, started = await future<newline>        if started:<newline>            print(f""{api_name} API: started on {port}"")<newline>        else:<newline>            log.logger.error(f""ERROR: {api_name} API cant start on {port}"")"
239	adjudicated	label-na	"def index():<newline>    return ""MindsDB Hanler Discovery"", 200"
240	adjudicated	label-na	"def register():<newline>    try:<newline>        params = request.json<newline>        host = params.get(""host"")<newline>        port = params.get(""port"")<newline>        _type = params.get(""type"")<newline>        Cache[(host, port)] = _type<newline>        return ""OK"", 200<newline>    except Exception as e:<newline>        return str(e), 500"
241	adjudicated	label-na	"def discover():<newline>    res = {}<newline>    try:<newline>        for k in Cache:<newline>            _type = Cache[k]<newline>            rec = {""host"": k[0], ""port"": k[1]}<newline>            if _type not in res:<newline>                res[_type] = [rec]<newline>            else:<newline>                res[_type].append(rec)<newline>    except Exception as e:<newline>        return {""error"": str(e)}, 500<newline>    return res, 200"
242	adjudicated	label-na	class QuietSimpleHTTPServer(SimpleHTTPRequestHandler):<newline>    def log_message(self, *args, **kwargs):<newline>        pass
243	adjudicated	label-na	class Context:<newline>    benchmarks: ClassVar[List[BaseRunner]] = []<newline>    stack: ExitStack = field(default_factory=ExitStack)<newline>    runner: pyperf.Runner = field(default_factory=pyperf.Runner)
244	adjudicated	label-na	"class BaseRunner:<newline>    """"""<newline>    An individual benchmark case. By default it has the category<newline>    (e.g like startup or download) and a name.<newline>    """""""
245	adjudicated	label-na	"class CommandRunner(BaseRunner):<newline>    """"""<newline>    Run a single command, and benchmark it.<newline>    """""""
246	adjudicated	label-na	def build_binaries() -> Iterator[Tuple[str, Path]]:<newline>    for target_script, extra_args in TARGET_SCRIPTS.items():<newline>        subprocess.check_call(<newline>            [<newline>                'pyinstaller',<newline>                '--onefile',<newline>                '--noupx',<newline>                '-p',<newline>                HTTPIE_DIR,<newline>                '--additional-hooks-dir',<newline>                HOOKS_DIR,<newline>                *extra_args,<newline>                target_script,<newline>            ]<newline>        )
247	adjudicated	label-na	def build_packages(http_binary: Path, httpie_binary: Path) -> None:<newline>    import httpie
248	adjudicated	label-na	def main():<newline>    binaries = dict(build_binaries())<newline>    build_packages(binaries['http_cli'], binaries['httpie_cli'])
249	adjudicated	label-na	"class FinishedForNow(Exception):<newline>    """"""Raised when remaining GitHub rate limit is zero.""""""<newline><newline>    def main(previous_release: str, current_release: str) -> int:<newline>    since = release_date(previous_release)<newline>    until = release_date(current_release)"
250	adjudicated	label-na	def find_committers(since: str, until: str) -> FullNames:<newline>    url = f'{REPO_URL}/commits'<newline>    page = 1<newline>    per_page = 100<newline>    params = {<newline>        'since': since,<newline>        'until': until,<newline>        'per_page': per_page,<newline>    }<newline>    committers: FullNames = set()
251	adjudicated	label-na	def find_reporters(since: str, until: str) -> GitHubLogins:<newline>    url = f'{API_URL}/search/issues'<newline>    page = 1<newline>    per_page = 100<newline>    params = {<newline>        'q': f'repo:{REPO}/{OWNER} is:issue closed:{since}..{until}',<newline>        'per_page': per_page,<newline>    }<newline>    reporters: GitHubLogins = set()
252	adjudicated	label-na	"def merge_all_the_people(release: str, contributors: People, committers: FullNames, reporters: GitHubLogins) -> None:<newline>    """"""<newline>    >>> contributors = {'Alice': new_person(github='alice', twitter='alice')}<newline>    >>> merge_all_the_people('2.6.0', contributors, {}, {})<newline>    >>> contributors<newline>    {'Alice': {'committed': [], 'reported': [], 'github': 'alice', 'twitter': 'alice'}}<newline>    """""""
253	adjudicated	label-na	def hook(hook_api):<newline>    for pkg in [<newline>        'pip',<newline>        'setuptools',<newline>        'distutils',<newline>        'pkg_resources'<newline>    ]:<newline>        datas, binaries, hiddenimports = collect_all(pkg)<newline>        hook_api.add_datas(datas)<newline>        hook_api.add_binaries(binaries)<newline>        hook_api.add_imports(*hiddenimports)
254	adjudicated	label-na	def generate_documentation() -> str:<newline>    database = load_database()<newline>    structure = build_docs_structure(database)<newline>    template = Template(source=TPL_FILE.read_text(encoding='utf-8'))<newline>    output = template.render(structure=structure)<newline>    output = clean_template_output(output)<newline>    return output
255	adjudicated	label-na	def save_doc_file(content: str) -> None:<newline>    current_doc = load_doc_file()<newline>    marker_start = current_doc.find(MARKER_START) + len(MARKER_START)<newline>    assert marker_start > 0, 'cannot find the start marker'<newline>    marker_end = current_doc.find(MARKER_END, marker_start)<newline>    assert marker_start < marker_end, f'{marker_end=} < {marker_start=}'<newline>    updated_doc = (<newline>        current_doc[:marker_start]<newline>        + '\n\n'<newline>        + content<newline>        + '\n\n'<newline>        + current_doc[marker_end:]<newline>    )<newline>    if current_doc != updated_doc:<newline>        DOC_FILE.write_text(updated_doc, encoding='utf-8')
256	adjudicated	label-na	def build_docs_structure(database: Database):<newline>    tools = database[KEY_TOOLS]<newline>    assert len(tools) == len({tool['title'] for tool in tools.values()}), 'tool titles need to be unique'<newline>    tree = database[KEY_DOC_STRUCTURE]<newline>    structure = []<newline>    for platform, tools_ids in tree.items():<newline>        assert platform.isalnum(), f'{platform=} must be alphanumeric for generated links to work'<newline>        platform_tools = [tools[tool_id] for tool_id in tools_ids]<newline>        structure.append((platform, platform_tools))<newline>    return structure<newline>
257	adjudicated	label-na	def clean_template_output(output):<newline>    output = '\n'.join(line.strip() for line in output.strip().splitlines())<newline>    output = re.sub('\n{3,}', '\n\n', output)<newline>    return output
258	adjudicated	label-na	def load_database() -> Database:<newline>    return yaml.safe_load(DB_FILE.read_text(encoding='utf-8'))
259	adjudicated	label-na	"def benchmark(ane):<newline>  tin = ANETensor(512*0x20)<newline>  tout = ANETensor(512*0x20)<newline>  dat = open(""../ops/gemm.hwx"", ""rb"").read()<newline>  for k,v in ane.debug(dat[0x4000:0x4300], 16).items():<newline>    print(k,v)<newline>  comp = ane.compile(dat)"
260	adjudicated	label-na	"def get_macho(fn):<newline>  # mod to make the header okay<newline>  # MH_CIGAM_64 is good<newline>  dat = open(fn, ""rb"").read()<newline>  dat = b""\xcf\xfa\xed\xfe""+dat[4:]<newline>  from tempfile import NamedTemporaryFile<newline>  with NamedTemporaryFile(delete=False) as f:<newline>    f.write(dat)<newline>    f.close()<newline>  return MachO.MachO(f.name)"
261	adjudicated	label-na	def compare(x, y):<newline>  ss = []<newline>  ln = []<newline>  ln2 = []
262	adjudicated	label-na	def fj(x):<newline>  ss = []<newline>  for i in range(0, 0x10, 4):<newline>    ss.append(' '.join(x[i:i+4]))<newline>  return '  '.join(ss)
263	adjudicated	label-na	class ANETensor:<newline>  def __init__(self, *shape):<newline>    self.shape = shape<newline>    self.dtype = np.float16<newline>    self.sz = int(np.prod(shape))<newline>    assert(self.sz <= 0x4000)<newline>    self.tt = libane.ANE_TensorCreate(self.sz, 1)<newline>    assert(self.tt is not None)
264	adjudicated	label-na	class ANE:<newline>  def __init__(self):<newline>    init_libane()<newline>    libane.ANE_Open()
265	adjudicated	label-na	"def init_libane():<newline>  global libane, aneregs<newline>  libane = cdll.LoadLibrary(os.path.join(basedir, ""libane.dylib""))"
266	adjudicated	label-na	def __init__(self, *shape):<newline>  self.shape = shape<newline>  self.dtype = np.float16<newline>  self.sz = int(np.prod(shape))<newline>  assert(self.sz <= 0x4000)<newline>  self.tt = libane.ANE_TensorCreate(self.sz, 1)<newline>  assert(self.tt is not None)
267	adjudicated	label-na	def data(self):<newline>  data = libane.ANE_TensorData(self.tt)<newline>  assert(data is not None)<newline>  #print(hex(addressof(data.contents)))<newline>  buf = np.ctypeslib.as_array(data, shape=(self.sz,))<newline>  ret = np.frombuffer(buf, dtype=self.dtype)<newline>  #print(ret.data)<newline>  return ret
268	adjudicated	label-na	"class vm_region_submap_short_info_data_64(ctypes.Structure):<newline>  _pack_ = 1<newline>  _fields_ = [<newline>      (""protection"", ctypes.c_uint32),<newline>      (""max_protection"", ctypes.c_uint32),<newline>      (""inheritance"", ctypes.c_uint32),<newline>      (""offset"", ctypes.c_ulonglong),<newline>      (""user_tag"", ctypes.c_uint32),<newline>      (""ref_count"", ctypes.c_uint32),<newline>      (""shadow_depth"", ctypes.c_uint16),<newline>      (""external_pager"", ctypes.c_byte),<newline>      (""share_mode"", ctypes.c_byte),<newline>      (""is_submap"", ctypes.c_uint32),<newline>      (""behavior"", ctypes.c_uint32),<newline>      (""object_id"", ctypes.c_uint32),<newline>      (""user_wired_count"", ctypes.c_uint32),<newline>  ]<newline>submap_info_size = ctypes.sizeof(vm_region_submap_short_info_data_64) // 4"
269	adjudicated	label-na	"def get_pid(name):<newline>  try:<newline>    output = check_output([""pgrep"", name])<newline>    return int(output)<newline>  except:<newline>    return None"
270	adjudicated	label-na	"class Challenge(jose.TypedJSONObjectWithFields):<newline>    # _fields_to_partial_json<newline>    """"""ACME challenge.""""""<newline>    TYPES: Dict[str, Type['Challenge']] = {}"
271	adjudicated	label-na	"class ChallengeResponse(jose.TypedJSONObjectWithFields):<newline>    # _fields_to_partial_json<newline>    """"""ACME challenge response.""""""<newline>    TYPES: Dict[str, Type['ChallengeResponse']] = {}"
272	adjudicated	label-na	"class UnrecognizedChallenge(Challenge):<newline>    """"""Unrecognized challenge."""""""
273	adjudicated	label-na	"class _TokenChallenge(Challenge):<newline>    """"""Challenge with token."""""""
274	adjudicated	label-na	"class KeyAuthorizationChallengeResponse(ChallengeResponse):<newline>    """"""Response to Challenges based on Key Authorization.<newline>    """""""
275	adjudicated	label-na	"class Fixed(jose.Field):<newline>    """"""Fixed field."""""""
276	adjudicated	label-na	"class RFC3339Field(jose.Field):<newline>    """"""RFC3339 field encoder/decoder.""""""<newline><newline>    def __init__(self, json_name: str, value: Any) -> None:<newline>    self.value = value<newline>    super().__init__(<newline>        json_name=json_name, default=value, omitempty=False)"
277	adjudicated	label-na	def decode(self, value: Any) -> Any:<newline>    if value != self.value:<newline>        raise jose.DeserializationError('Expected {0!r}'.format(self.value))<newline>    return self.value
278	adjudicated	label-na	def encode(self, value: Any) -> Any:<newline>    if value != self.value:<newline>        logger.warning(<newline>            'Overriding fixed field (%s) with %r', self.json_name, value)<newline>    return value
279	adjudicated	label-na	class _DefaultCertSelection:<newline>    def __init__(self, certs: Mapping[bytes, Tuple[crypto.PKey, crypto.X509]]):<newline>        self.certs = certs
280	adjudicated	label-na	"class SSLSocket:  # pylint: disable=too-few-public-methods<newline>    """"""SSL wrapper for sockets."""""""
281	adjudicated	label-na	"class FakeConnection:<newline>    """"""Fake OpenSSL.SSL.Connection.""""""<newline><newline>    def __init__(self, certs: Mapping[bytes, Tuple[crypto.PKey, crypto.X509]]):<newline>        self.certs = certs<newline><newline>    def __call__(self, connection: SSL.Connection) -> Optional[Tuple[crypto.PKey, crypto.X509]]:<newline>        server_name = connection.get_servername()<newline>        if server_name:<newline>            return self.certs.get(server_name, None)<newline>        return None # pragma: no cover"
282	adjudicated	label-na	"class Error(Exception):<newline>    """"""Generic ACME error."""""""
283	adjudicated	label-na	"class DependencyError(Error):<newline>    """"""Dependency error"""""""
284	adjudicated	label-na	"class SchemaValidationError(jose_errors.DeserializationError):<newline>    """"""JSON schema ACME object validation error."""""""
285	adjudicated	label-na	"class ClientError(Error):<newline>    """"""Network error."""""""
286	adjudicated	label-na	"class UnexpectedUpdate(ClientError):<newline>    """"""Unexpected update error."""""""
287	adjudicated	label-na	"class _Constant(jose.JSONDeSerializable, Hashable):<newline>    """"""ACME constant.""""""<newline>    __slots__ = ('name',)<newline>    POSSIBLE_NAMES: Dict[str, '_Constant'] = NotImplemented"
288	adjudicated	label-na	"class IdentifierType(_Constant):<newline>    """"""ACME identifier type.""""""<newline>    POSSIBLE_NAMES: Dict[str, _Constant] = {}"
289	adjudicated	label-na	"class Identifier(jose.JSONObjectWithFields):<newline>    """"""ACME identifier."""""""
290	adjudicated	label-na	"class Error(jose.JSONObjectWithFields, errors.Error):<newline>    """"""ACME error."""""""
291	adjudicated	label-na	"class Status(_Constant):<newline>    """"""ACME ""status"" field.""""""<newline>    POSSIBLE_NAMES: Dict[str, _Constant] = {}"
292	adjudicated	label-na	"class Header(jose.Header):<newline>    """"""ACME-specific JOSE Header. Implements nonce, kid, and url.<newline>    """"""<newline>    nonce: Optional[bytes] = jose.field('nonce', omitempty=True, encoder=jose.encode_b64jose)<newline>    kid: Optional[str] = jose.field('kid', omitempty=True)<newline>    url: Optional[str] = jose.field('url', omitempty=True)"
293	adjudicated	label-na	"class Signature(jose.Signature):<newline>    """"""ACME-specific Signature. Uses ACME-specific Header for customer fields.""""""<newline>    __slots__ = jose.Signature._orig_slots  # type: ignore[attr-defined]  # pylint: disable=protected-access,no-member"
294	adjudicated	label-na	"class JWS(jose.JWS):<newline>    """"""ACME-specific JWS. Includes none, url, and kid in protected header.""""""<newline>    signature_cls = Signature<newline>    __slots__ = jose.JWS._orig_slots  # type: ignore[attr-defined]  # pylint: disable=protected-access"
295	adjudicated	label-na	"def nonce(value: str) -> bytes:  # type: ignore[misc]  # pylint: disable=no-self-argument,missing-function-docstring<newline>    try:<newline>        return jose.decode_b64jose(value)<newline>    except jose.DeserializationError as error:<newline>        # TODO: custom error<newline>        raise jose.DeserializationError(""Invalid nonce: {0}"".format(error))"
296	adjudicated	label-na	def sign(cls, payload: bytes, key: jose.JWK, alg: jose.JWASignature, nonce: Optional[bytes],<newline>         url: Optional[str] = None, kid: Optional[str] = None) -> jose.JWS:<newline>    # Per ACME spec, jwk and kid are mutually exclusive, so only include a<newline>    # jwk field if kid is not provided.<newline>    include_jwk = kid is None<newline>    return super().sign(payload, key=key, alg=alg,<newline>                        protect=frozenset(['nonce', 'url', 'kid', 'jwk', 'alg']),<newline>                        nonce=nonce, url=url, kid=kid,<newline>                        include_jwk=include_jwk)
297	adjudicated	label-na	"class ClientV2:<newline>    """"""ACME client for a v2 API."""""""
298	adjudicated	label-na	"class ClientNetwork:<newline>    """"""Wrapper around requests that signs POSTs for authentication.<newline>    """""""
299	adjudicated	label-na	"def __init__(self, directory: messages.Directory, net: 'ClientNetwork') -> None:<newline>    """"""Initialize."""""""
300	adjudicated	label-na	"def new_account(self, new_account: messages.NewRegistration) -> messages.RegistrationResource:<newline>    """"""Register."""""""
301	adjudicated	label-na	"def query_registration(self, regr: messages.RegistrationResource<newline>                       ) -> messages.RegistrationResource:<newline>    """"""Query server about registration."""""""
302	adjudicated	label-na	def get_random_crop_coords(height: int, width: int, crop_height: int, crop_width: int, h_start: float, w_start: float):<newline>    # h_start is [0, 1) and should map to [0, (height - crop_height)]  (note inclusive)<newline>    # This is conceptually equivalent to mapping onto `range(0, (height - crop_height + 1))`<newline>    # See: https://github.com/albumentations-team/albumentations/pull/1080<newline>    y1 = int((height - crop_height + 1) * h_start)<newline>    y2 = y1 + crop_height<newline>    x1 = int((width - crop_width + 1) * w_start)<newline>    x2 = x1 + crop_width<newline>    return x1, y1, x2, y2
303	adjudicated	label-na	"def random_crop(img: np.ndarray, crop_height: int, crop_width: int, h_start: float, w_start: float):<newline>    height, width = img.shape[:2]<newline>    if height < crop_height or width < crop_width:<newline>        raise ValueError(<newline>            ""Requested crop size ({crop_height}, {crop_width}) is ""<newline>            ""larger than the image size ({height}, {width})"".format(<newline>                crop_height=crop_height, crop_width=crop_width, height=height, width=width<newline>            )<newline>        )<newline>    x1, y1, x2, y2 = get_random_crop_coords(height, width, crop_height, crop_width, h_start, w_start)<newline>    img = img[y1:y2, x1:x2]<newline>    return img"
304	adjudicated	label-na	"def crop_bbox_by_coords(<newline>    bbox: BoxInternalType,<newline>    crop_coords: Tuple[int, int, int, int],<newline>    crop_height: int,<newline>    crop_width: int,<newline>    rows: int,<newline>    cols: int,<newline>):<newline>    """"""Crop a bounding box using the provided coordinates of bottom-left and top-right corners in pixels and the<newline>    required height and width of the crop."""""""
305	adjudicated	label-na	def bbox_random_crop(<newline>    bbox: BoxInternalType, crop_height: int, crop_width: int, h_start: float, w_start: float, rows: int, cols: int<newline>):<newline>    crop_coords = get_random_crop_coords(rows, cols, crop_height, crop_width, h_start, w_start)<newline>    return crop_bbox_by_coords(bbox, crop_coords, crop_height, crop_width, rows, cols)
306	adjudicated	label-na	"def crop_keypoint_by_coords(<newline>    keypoint: KeypointInternalType, crop_coords: Tuple[int, int, int, int]<newline>):  # skipcq: PYL-W0613<newline>    """"""Crop a keypoint using the provided coordinates of bottom-left and top-right corners in pixels and the<newline>    required height and width of the crop."
307	adjudicated	label-na	"class Blur(ImageOnlyTransform):<newline>    """"""Blur the input image using a random-sized kernel.<newline>    """""""
308	adjudicated	label-na	"class MotionBlur(Blur):<newline>    """"""Apply motion blur to the input image using a random-sized kernel.<newline>    """""""
309	adjudicated	label-na	"class MedianBlur(Blur):<newline>    """"""Blur the input image using a median filter with a random aperture linear size.<newline>    """""""
310	adjudicated	label-na	"class GaussianBlur(ImageOnlyTransform):<newline>    """"""Blur the input image using a Gaussian filter with a random kernel size.<newline>    """""""
311	adjudicated	label-na	"class GlassBlur(Blur):<newline>    """"""Apply glass noise to the input image."""""""
312	adjudicated	label-na	class Command:<newline>    def __init__(self, argv: Optional[str] = None) -> None:<newline>        self.argv = argv or sys.argv[:]<newline>        self.prog_name = Path(self.argv[0]).name
313	adjudicated	label-na	def print_provider(<newline>    doc: Documentor,<newline>    provider: BaseProvider,<newline>    formatters: Dict[str, T],<newline>    excludes: Optional[List[str]] = None,<newline>    output: Optional[TextIO] = None,<newline>) -> None:<newline>    if output is None:<newline>        output = sys.stdout<newline>    if excludes is None:<newline>        excludes = []
314	adjudicated	label-na	def print_doc(<newline>    provider_or_field: Optional[str] = None,<newline>    args: Optional[List[T]] = None,<newline>    lang: str = DEFAULT_LOCALE,<newline>    output: Optional[Union[TextIO, TextIOWrapper]] = None,<newline>    seed: Optional[float] = None,<newline>    includes: Optional[List[str]] = None,<newline>) -> None:<newline>    if args is None:<newline>        args = []<newline>    if output is None:<newline>        output = sys.stdout<newline>    fake = Faker(locale=lang, includes=includes)<newline>    fake.seed_instance(seed)
315	adjudicated	label-na	def __init__(self, argv: Optional[str] = None) -> None:<newline>    self.argv = argv or sys.argv[:]<newline>    self.prog_name = Path(self.argv[0]).name
316	adjudicated	label-na	"def _session_faker(request):<newline>    """"""Fixture that stores the session level ``Faker`` instance."
317	adjudicated	label-na	"def faker(request):<newline>    """"""Fixture that returns a seeded and suitable ``Faker`` instance.""""""<newline>    if ""faker_locale"" in request.fixturenames:<newline>        locale = request.getfixturevalue(""faker_locale"")<newline>        fake = Faker(locale=locale)<newline>    else:<newline>        fake = request.getfixturevalue(""_session_faker"")"
318	adjudicated	label-na	"def timer(func):<newline>    @functools.wraps(func)<newline>    async def wrapper(*args, **kwargs):<newline>        tic = time.perf_counter()<newline>        await func(*args, **kwargs)<newline>        toc = time.perf_counter()<newline>        return f""{toc - tic:.4f}"""
319	adjudicated	label-na	"async def wrapper(*args, **kwargs):<newline>    tic = time.perf_counter()<newline>    await func(*args, **kwargs)<newline>    toc = time.perf_counter()<newline>    return f""{toc - tic:.4f}"""
320	adjudicated	label-na	"async def set_str(client, gather, data):<newline>    if gather:<newline>        for _ in range(count // 100):<newline>            await asyncio.gather(<newline>                *(<newline>                    asyncio.create_task(client.set(f""bench:str_{i}"", data))<newline>                    for i in range(100)<newline>                )<newline>            )<newline>    else:<newline>        for i in range(count):<newline>            await client.set(f""bench:str_{i}"", data)"
321	adjudicated	label-na	"async def set_int(client, gather, data):<newline>    if gather:<newline>        for _ in range(count // 100):<newline>            await asyncio.gather(<newline>                *(<newline>                    asyncio.create_task(client.set(f""bench:int_{i}"", data))<newline>                    for i in range(100)<newline>                )<newline>            )<newline>    else:<newline>        for i in range(count):<newline>            await client.set(f""bench:int_{i}"", data)"
322	adjudicated	label-na	"async def get_str(client, gather):<newline>    if gather:<newline>        for _ in range(count // 100):<newline>            await asyncio.gather(<newline>                *(asyncio.create_task(client.get(f""bench:str_{i}"")) for i in range(100))<newline>            )<newline>    else:<newline>        for i in range(count):<newline>            await client.get(f""bench:str_{i}"")"
323	adjudicated	label-na	"class Benchmark:<newline>    ARGUMENTS = ()<newline><newline>    def __init__(self):<newline>        self._client = None<newline><newline>    def get_client(self, **kwargs):<newline>        # eventually make this more robust and take optional args from<newline>        # argparse<newline>        if self._client is None or kwargs:<newline>            defaults = {""db"": 9}<newline>            defaults.update(kwargs)<newline>            pool = redis.ConnectionPool(**kwargs)<newline>            self._client = redis.Redis(connection_pool=pool)<newline>        return self._client<newline><newline>     def setup(self, **kwargs):<newline>        pass<newline><newline>    def run(self, **kwargs):<newline>        pass"
324	adjudicated	label-na	def __init__(self):<newline>    self._client = None
325	adjudicated	label-na	"def get_client(self, **kwargs):<newline>    # eventually make this more robust and take optional args from<newline>    # argparse<newline>    if self._client is None or kwargs:<newline>        defaults = {""db"": 9}<newline>        defaults.update(kwargs)<newline>        pool = redis.ConnectionPool(**kwargs)<newline>        self._client = redis.Redis(connection_pool=pool)<newline>    return self._client"
326	adjudicated	label-na	def setup(self, **kwargs):<newline>    pass
327	adjudicated	label-na	def run(self, **kwargs):<newline>    pass
328	adjudicated	label-na	"class StringJoiningConnection(Connection):<newline>    def send_packed_command(self, command, check_health=True):<newline>        ""Send an already packed command to the Redis server""<newline>        if not self._sock:<newline>            self.connect()<newline>        try:<newline>            self._sock.sendall(command)<newline>        except OSError as e:<newline>            self.disconnect()<newline>            if len(e.args) == 1:<newline>                _errno, errmsg = ""UNKNOWN"", e.args[0]<newline>            else:<newline>                _errno, errmsg = e.args<newline>            raise ConnectionError(f""Error {_errno} while writing to socket. {errmsg}."")<newline>        except Exception:<newline>            self.disconnect()<newline>            raise"
329	adjudicated	label-na	"class ListJoiningConnection(Connection):<newline>    def send_packed_command(self, command, check_health=True):<newline>        if not self._sock:<newline>            self.connect()<newline>        try:<newline>            if isinstance(command, str):<newline>                command = [command]<newline>            for item in command:<newline>                self._sock.sendall(item)<newline>        except OSError as e:<newline>            self.disconnect()<newline>            if len(e.args) == 1:<newline>                _errno, errmsg = ""UNKNOWN"", e.args[0]<newline>            else:<newline>                _errno, errmsg = e.args<newline>            raise ConnectionError(f""Error {_errno} while writing to socket. {errmsg}."")<newline>        except Exception:<newline>            self.disconnect()<newline>            raise"
330	adjudicated	label-na	"def pack_command(self, *args):<newline>    ""Pack a series of arguments into a value Redis command""<newline>    args_output = SYM_EMPTY.join(<newline>        [<newline>            SYM_EMPTY.join(<newline>                (SYM_DOLLAR, str(len(k)).encode(), SYM_CRLF, k, SYM_CRLF)<newline>            )<newline>            for k in map(self.encoder.encode, args)<newline>        ]<newline>    )<newline>    output = SYM_EMPTY.join(<newline>        (SYM_STAR, str(len(args)).encode(), SYM_CRLF, args_output)<newline>    )<newline>    return output"
331	adjudicated	label-na	"def timer(func):<newline>    @functools.wraps(func)<newline>    async def wrapper(*args, **kwargs):<newline>        tic = time.perf_counter()<newline>        await func(*args, **kwargs)<newline>        toc = time.perf_counter()<newline>        return f""{toc - tic:.4f}"""
332	adjudicated	label-na	"async def wrapper(*args, **kwargs):<newline>    tic = time.perf_counter()<newline>    await func(*args, **kwargs)<newline>    toc = time.perf_counter()<newline>    return f""{toc - tic:.4f}"""
333	adjudicated	label-na	"async def warmup(client):<newline>    await asyncio.gather(<newline>        *(asyncio.create_task(client.exists(f""bench:warmup_{i}"")) for i in range(100))<newline>    )"
334	adjudicated	label-na	"async def run(client):<newline>    data_str = ""a"" * size<newline>    data_int = int(""1"" * size)"
335	adjudicated	label-na	"async def main(loop):<newline>    arc = aredis.StrictRedisCluster(<newline>        host=host,<newline>        port=port,<newline>        password=password,<newline>        max_connections=2**31,<newline>        max_connections_per_node=2**31,<newline>        readonly=False,<newline>        reinitialize_steps=count,<newline>        skip_full_coverage_check=True,<newline>        decode_responses=False,<newline>        max_idle_time=count,<newline>        idle_check_interval=count,<newline>    )<newline>    print(f""{loop} {await warmup(arc)} aredis"")<newline>    print(await run(arc))<newline>    arc.connection_pool.disconnect()"
336	adjudicated	label-na	"def parse_args():<newline>    parser = ArgumentParser()<newline>    parser.add_argument(<newline>        ""-n"", type=int, help=""Total number of requests (default 100000)"", default=100000<newline>    )<newline>    parser.add_argument(<newline>        ""-P"",<newline>        type=int,<newline>        help=(""Pipeline <numreq> requests. Default 1 (no pipeline).""),<newline>        default=1,<newline>    )<newline>    parser.add_argument(<newline>        ""-s"",<newline>        type=int,<newline>        help=""Data size of SET/GET value in bytes (default 2)"",<newline>        default=2,<newline>    )"
337	adjudicated	label-na	def run():<newline>    args = parse_args()<newline>    r = redis.Redis()<newline>    r.flushall()<newline>    set_str(conn=r, num=args.n, pipeline_size=args.P, data_size=args.s)<newline>    set_int(conn=r, num=args.n, pipeline_size=args.P, data_size=args.s)<newline>    get_str(conn=r, num=args.n, pipeline_size=args.P, data_size=args.s)<newline>    get_int(conn=r, num=args.n, pipeline_size=args.P, data_size=args.s)<newline>    incr(conn=r, num=args.n, pipeline_size=args.P, data_size=args.s)<newline>    lpush(conn=r, num=args.n, pipeline_size=args.P, data_size=args.s)<newline>    lrange_300(conn=r, num=args.n, pipeline_size=args.P, data_size=args.s)<newline>    lpop(conn=r, num=args.n, pipeline_size=args.P, data_size=args.s)<newline>    hmset(conn=r, num=args.n, pipeline_size=args.P, data_size=args.s)
338	adjudicated	label-na	"def timer(func):<newline>    @wraps(func)<newline>    def wrapper(*args, **kwargs):<newline>        start = time.monotonic()<newline>        ret = func(*args, **kwargs)<newline>        duration = time.monotonic() - start<newline>        if ""num"" in kwargs:<newline>            count = kwargs[""num""]<newline>        else:<newline>            count = args[1]<newline>        print(f""{func.__name__} - {count} Requests"")<newline>        print(f""Duration  = {duration}"")<newline>        print(f""Rate = {count/duration}"")<newline>        print()<newline>        return ret"
339	adjudicated	label-na	"def wrapper(*args, **kwargs):<newline>    start = time.monotonic()<newline>    ret = func(*args, **kwargs)<newline>    duration = time.monotonic() - start<newline>    if ""num"" in kwargs:<newline>        count = kwargs[""num""]<newline>    else:<newline>        count = args[1]<newline>    print(f""{func.__name__} - {count} Requests"")<newline>    print(f""Duration  = {duration}"")<newline>    print(f""Rate = {count/duration}"")<newline>    print()<newline>    return ret"
340	adjudicated	label-na	def set_str(conn, num, pipeline_size, data_size):<newline>    if pipeline_size > 1:<newline>        conn = conn.pipeline()
341	adjudicated	label-na	"def setup(self, value_size, read_size, parser):<newline>    r = self.get_client(parser_class=parser, socket_read_size=read_size)<newline>    r.set(""benchmark"", ""a"" * value_size)"
342	adjudicated	label-na	"def run(self, value_size, read_size, parser):<newline>    r = self.get_client()<newline>    r.get(""benchmark"")"
343	adjudicated	label-na	def to_int(value):<newline>    value = ''.join((x for x in value if x.isdigit()))<newline>    try:<newline>        return int(value)<newline>    except Exception:<newline>        return 0
344	adjudicated	label-na	def to_tuple(version):<newline>    return tuple(to_int(x) for x in version.split('.'))
345	adjudicated	label-na	def main():<newline>    project = sys.argv[1]<newline>    json = requests.get('https://pypi.org/pypi/%s/json' % project).json()<newline>    for version in sorted(json['releases'], key=to_tuple):<newline>        print(version)<newline>        wheel_packages = [<newline>            p for p in json['releases'][version]<newline>            if p['packagetype'] == 'bdist_wheel'<newline>        ]<newline>        for p in wheel_packages:<newline>            print('    %(python_version)s %(filename)s' % p)
346	adjudicated	label-na	"def _notebook_run(path):<newline>    """"""Execute a notebook via nbconvert and collect output.<newline>       :returns (parsed nb object, execution errors)<newline>    """"""<newline>    kernel_name = 'python%d' % sys.version_info[0]<newline>    this_file_directory = os.path.dirname(__file__)<newline>    errors = []<newline>    with tempfile.NamedTemporaryFile(suffix="".ipynb"", mode='wt') as fout:<newline>        with smart_open(path, 'rb') as f:<newline>            nb = nbformat.read(f, as_version=4)<newline>            nb.metadata.get('kernelspec', {})['name'] = kernel_name<newline>            ep = ExecutePreprocessor(kernel_name=kernel_name, timeout=10)"
347	adjudicated	label-na	"def test_notebooks():<newline>    for notebook in glob(""*.ipynb""):<newline>        if "" "" in notebook:<newline>            continue<newline>        print(""Testing {}"".format(notebook))<newline>        nb, errors = _notebook_run(notebook)<newline>        assert errors == []"
348	adjudicated	label-na	class MyCorpus:<newline>    def __iter__(self):<newline>        for line in open('https://radimrehurek.com/mycorpus.txt'):<newline>            # assume there's one document per line, tokens separated by whitespace<newline>            yield dictionary.doc2bow(line.lower().split())
349	adjudicated	label-na	def __iter__(self):<newline>    for line in open('https://radimrehurek.com/mycorpus.txt'):<newline>        # assume there's one document per line, tokens separated by whitespace<newline>        yield dictionary.doc2bow(line.lower().split())
350	adjudicated	label-na	"class BaseAdapter:<newline>    """"""The Base Transport Adapter"""""""
351	adjudicated	label-na	"class HTTPAdapter(BaseAdapter):<newline>    """"""The built-in HTTP Adapter for urllib3.<newline>    """""""
352	adjudicated	label-na	"def request(method, url, **kwargs):<newline>    """"""Constructs and sends a :class:`Request <Request>`.<newline>    """""""
353	adjudicated	label-na	"def get(url, params=None, **kwargs):<newline>    r""""""Sends a GET request.<newline>    """"""<newline>"
354	adjudicated	label-na	"def options(url, **kwargs):<newline>    r""""""Sends an OPTIONS request.<newline>    """""""
355	adjudicated	label-na	"def head(url, **kwargs):<newline>    r""""""Sends a HEAD request.<newline>    """""""
356	adjudicated	label-na	"def post(url, data=None, json=None, **kwargs):<newline>    r""""""Sends a POST request.<newline>    """""""
357	adjudicated	label-na	"class FlaskyStyle(Style):<newline>    background_color = ""#f8f8f8""<newline>    default_style = """""
358	adjudicated	label-na	"class AuthBase:<newline>    """"""Base class that all auth implementations derive from"""""""
359	adjudicated	label-na	"class HTTPBasicAuth(AuthBase):<newline>    """"""Attaches HTTP Basic Authentication to the given Request object."""""""
360	adjudicated	label-na	"class HTTPProxyAuth(HTTPBasicAuth):<newline>    """"""Attaches HTTP Proxy Authentication to a given Request object."""""""
361	adjudicated	label-na	"class HTTPDigestAuth(AuthBase):<newline>    """"""Attaches HTTP Digest Authentication to the given Request object."""""""
362	adjudicated	label-na	"def to_native_string(string, encoding=""ascii""):<newline>    """"""Given a string object, regardless of type, returns a representation of<newline>    that string in the native string type, encoding and decoding where<newline>    necessary. This assumes ASCII unless told otherwise.<newline>    """"""<newline>    if isinstance(string, builtin_str):<newline>        out = string<newline>    else:<newline>        out = string.decode(encoding)"
363	adjudicated	label-na	"def unicode_is_ascii(u_string):<newline>    """"""Determine if unicode string only contains ASCII characters.<newline>    """""""
364	adjudicated	label-na	"def check_compatibility(urllib3_version, chardet_version, charset_normalizer_version):<newline>    urllib3_version = urllib3_version.split(""."")<newline>    assert urllib3_version != [""dev""]  # Verify urllib3 isn't installed from git."
365	adjudicated	label-na	"def _check_cryptography(cryptography_version):<newline>    # cryptography < 1.3.4<newline>    try:<newline>        cryptography_version = list(map(int, cryptography_version.split(""."")))<newline>    except ValueError:<newline>        return"
366	adjudicated	label-na	class CompletionRefresher(object):
367	adjudicated	label-na	def __init__(self):<newline>    self._completer_thread = None<newline>    self._restart_refresh = threading.Event()
368	adjudicated	label-na	"def refresh(self, executor, callbacks, completer_options=None):<newline>    """"""Creates a SQLCompleter object and populates it with the relevant<newline>    completion suggestions in a background thread.<newline>    """""""
369	adjudicated	label-na	def is_refreshing(self):<newline>    return self._completer_thread and self._completer_thread.is_alive()
370	adjudicated	label-na	def _bg_refresh(self, sqlexecute, callbacks, completer_options):<newline>    completer = SQLCompleter(**completer_options)
371	adjudicated	label-na	"class OutputStyle(PygmentsStyle):<newline>    default_style = """"<newline>    styles = style"
372	adjudicated	label-na	"def parse_pygments_style(token_name, style_object, style_dict):<newline>    """"""Parse token type and style string.<newline>    """""""
373	adjudicated	label-na	"def mycli_bindings(mycli):<newline>    """"""Custom key bindings for mycli.""""""<newline>    kb = KeyBindings()"
374	adjudicated	label-na	"def _(event):<newline>    """"""Enable/Disable SmartCompletion Mode.""""""<newline>    _logger.debug('Detected F2 key.')<newline>    mycli.completer.smart_completion = not mycli.completer.smart_completion"
375	adjudicated	label-na	"def _(event):<newline>    """"""Enable/Disable Multiline Mode.""""""<newline>    _logger.debug('Detected F3 key.')<newline>    mycli.multi_line = not mycli.multi_line"
376	adjudicated	label-na	"def _(event):<newline>    """"""Toggle between Vi and Emacs mode.""""""<newline>    _logger.debug('Detected F4 key.')<newline>    if mycli.key_bindings == ""vi"":<newline>        event.app.editing_mode = EditingMode.EMACS<newline>        mycli.key_bindings = ""emacs""<newline>    else:<newline>        event.app.editing_mode = EditingMode.VI<newline>        mycli.key_bindings = ""vi"""
377	adjudicated	label-na	"def _(event):<newline>    """"""Force autocompletion at cursor.""""""<newline>    _logger.debug('Detected <Tab> key.')<newline>    b = event.app.current_buffer<newline>    if b.complete_state:<newline>        b.complete_next()<newline>    else:<newline>        b.start_completion(select_first=True)"
378	adjudicated	label-na	"def log(logger, level, message):<newline>    """"""Logs message to stderr if logging isn't initialized."""""""
379	adjudicated	label-na	"def read_config_file(f, list_values=True):<newline>    """"""Read a config file.<newline>    """""""
380	adjudicated	label-na	"def get_included_configs(config_file: Union[str, TextIOWrapper]) -> list:<newline>    """"""Get a list of configuration files that are included into config_path<newline>    with !includedir directive.<newline>    """""""
381	adjudicated	label-na	"def read_config_files(files, list_values=True):<newline>    """"""Read and merge a list of config files."""""""
382	adjudicated	label-na	def create_default_config(list_values=True):<newline>    import mycli<newline>    default_config_file = resources.open_text(mycli, 'myclirc')<newline>    return read_config_file(default_config_file, list_values=list_values)
383	adjudicated	label-na	def cli_is_multiline(mycli):<newline>    @Condition<newline>    def cond():<newline>        doc = get_app().layout.get_buffer_by_name(DEFAULT_BUFFER).document
384	adjudicated	label-na	def cond():<newline>    doc = get_app().layout.get_buffer_by_name(DEFAULT_BUFFER).document
385	adjudicated	label-na	def _multiline_exception(text):<newline>    orig = text<newline>    text = text.strip()
386	adjudicated	label-na	"def create_toolbar_tokens_func(mycli, show_fish_help):<newline>    """"""Return a function that generates the toolbar tokens.""""""<newline>    def get_toolbar_tokens():<newline>        result = []<newline>        result.append(('class:bottom-toolbar', ' '))"
387	adjudicated	label-na	def get_toolbar_tokens():<newline>    result = []<newline>    result.append(('class:bottom-toolbar', ' '))
388	adjudicated	label-na	"def _get_vi_mode():<newline>    """"""Get the current vi mode for display.""""""<newline>    return {<newline>        InputMode.INSERT: 'I',<newline>        InputMode.NAVIGATION: 'N',<newline>        InputMode.REPLACE: 'R',<newline>        InputMode.REPLACE_SINGLE: 'R',<newline>        InputMode.INSERT_MULTIPLE: 'M',<newline>    }[get_app().vi_state.input_mode]"
389	adjudicated	label-na	"class CountInstances(Subcommand):<newline>    def add_subparser(self, parser: argparse._SubParsersAction) -> argparse.ArgumentParser:<newline>        description = """"""Count the number of training instances in an experiment config file.""""""<newline>        subparser = parser.add_parser(self.name, description=description, help=description)<newline>        subparser.add_argument(""param_path"", type=str, help=""path to an experiment config file"")"
390	adjudicated	label-na	def count_instances_from_args(args: argparse.Namespace):<newline>    from allennlp.training.util import data_loaders_from_params
391	adjudicated	label-na	class CheckList(Subcommand):<newline>    def add_subparser(self, parser: argparse._SubParsersAction) -> argparse.ArgumentParser:
392	adjudicated	label-na	"class _CheckListManager:<newline>    def __init__(<newline>        self,<newline>        task_suite: TaskSuite,<newline>        predictor: Predictor,<newline>        capabilities: Optional[List[str]] = None,<newline>        max_examples: Optional[int] = None,<newline>        output_file: Optional[str] = None,<newline>        print_summary_args: Optional[Dict[str, Any]] = None,<newline>    ) -> None:<newline>        self._task_suite = task_suite<newline>        self._predictor = predictor<newline>        self._capabilities = capabilities<newline>        self._max_examples = max_examples<newline>        self._output_file = None if output_file is None else open(output_file, ""w"")<newline>        self._print_summary_args = print_summary_args or {}"
393	adjudicated	label-na	def _get_predictor(args: argparse.Namespace) -> Predictor:<newline>    check_for_gpu(args.cuda_device)<newline>    archive = load_archive(<newline>        args.archive_file,<newline>        cuda_device=args.cuda_device,<newline>    )
394	adjudicated	label-na	"def _get_task_suite(args: argparse.Namespace) -> TaskSuite:<newline>    available_tasks = TaskSuite.list_available()<newline>    if args.task in available_tasks:<newline>        suite_name = args.task<newline>    else:<newline>        raise ConfigurationError(<newline>            f""'{args.task}' is not a recognized task suite. ""<newline>            f""Available tasks are: {available_tasks}.""<newline>        )"
395	adjudicated	label-na	"class BuildVocab(Subcommand):<newline>    def add_subparser(self, parser: argparse._SubParsersAction) -> argparse.ArgumentParser:<newline>        description = """"""Build a vocabulary from an experiment config file.""""""<newline>        subparser = parser.add_parser(self.name, description=description, help=description)"
396	adjudicated	label-na	"def add_subparser(self, parser: argparse._SubParsersAction) -> argparse.ArgumentParser:<newline>    description = """"""Build a vocabulary from an experiment config file.""""""<newline>    subparser = parser.add_parser(self.name, description=description, help=description)"
397	adjudicated	label-na	"def build_vocab_from_args(args: argparse.Namespace):<newline>    if not args.output_path.endswith("".tar.gz""):<newline>        raise ValueError(""param 'output_path' should end with '.tar.gz'"")"
398	adjudicated	label-na	"def _transformers_log_filter(record):<newline>    if record.msg.startswith(""PyTorch version""):<newline>        return False<newline>    return True"
399	adjudicated	label-na	def run():<newline>    from allennlp.commands import main  # noqa<newline>    from allennlp.common.util import install_sigterm_handler
400	adjudicated	label-na	"class ArgumentParserWithDefaults(argparse.ArgumentParser):<newline>    """"""<newline>    Custom argument parser that will display the default value for an argument<newline>    in the help message.<newline>    """""""
401	adjudicated	label-na	def _is_empty_default(default: Any) -> bool:<newline>    if default is None:<newline>        return True<newline>    if isinstance(default, (str, list, tuple, set)):<newline>        return not bool(default)<newline>    return False
402	adjudicated	label-na	"def add_argument(self, *args, **kwargs):<newline>    # Add default value to the help message when the default is meaningful.<newline>    default = kwargs.get(""default"")<newline>    if kwargs.get(<newline>        ""action""<newline>    ) not in self._action_defaults_to_ignore and not self._is_empty_default(default):<newline>        description = kwargs.get(""help"", """")<newline>        kwargs[""help""] = f""{description} (default = {default})""<newline>    super().add_argument(*args, **kwargs)"
403	adjudicated	label-na	"def parse_args(prog: Optional[str] = None) -> Tuple[argparse.ArgumentParser, argparse.Namespace]:<newline>    """"""<newline>    Creates the argument parser for the main program and uses it to parse the args.<newline>    """"""<newline>    parser = ArgumentParserWithDefaults(description=""Run AllenNLP"", prog=prog)<newline>    parser.add_argument(""--version"", action=""version"", version=f""%(prog)s {__version__}"")"
404	adjudicated	label-na	"def add_subcommands():<newline>    for subcommand_name in sorted(Subcommand.list_available()):<newline>        if subcommand_name in subcommands:<newline>            continue<newline>        subcommands.add(subcommand_name)<newline>        subcommand_class = Subcommand.by_name(subcommand_name)<newline>        subcommand = subcommand_class()<newline>        subparser = subcommand.add_subparser(subparsers)<newline>        if subcommand_class.requires_plugins:<newline>            subparser.add_argument(<newline>                ""--include-package"",<newline>                type=str,<newline>                action=""append"",<newline>                default=[],<newline>                    help=""additional packages to include"",<newline>        )"
405	adjudicated	label-na	class CachedPath(Subcommand):<newline>    requires_plugins: bool = False
406	adjudicated	label-na	"def add_subparser(self,<newline>                  parser: argparse._SubParsersAction) -> argparse.ArgumentParser:<newline>    description = """"""Cache remote files to the AllenNLP cache.""""""<newline>    subparser = parser.add_parser(<newline>        self.name,<newline>        description=description,<newline>        help=description,<newline>    )<newline>    subparser.set_defaults(func=_cached_path)<newline>    subparser.add_argument(<newline>        ""resources"",<newline>        type=str,<newline>        help=""""""The URLs or paths to the resources.<newline>        If using the --inspect or --remove flag, this can also contain glob patterns."""""",<newline>        nargs=""*"",<newline>    )<newline>    subparser.add_argument(<newline>        ""-d"",<newline>        ""--cache-dir"",<newline>        type=str,<newline>        help=""""""Use a custom cache directory."""""",<newline>        default=CACHE_DIRECTORY,<newline>    )<newline>    subparser.add_argument(<newline>        ""-x"",<newline>        ""--extract-archive"",<newline>        action=""store_true"",<newline>        help=""""""Automatically extract zip or tar.gz archive files."""""",<newline>    )<newline>    subparser.add_argument(<newline>        ""-f"",<newline>        ""--force-extract"",<newline>        action=""store_true"",<newline>        help=""""""Extract archives regardless of whether or not they already exist."""""",<newline>    )<newline>    subparser.add_argument(<newline>        ""--inspect"",<newline>        action=""store_true"",<newline>        help=""""""Print some useful information about the cache."""""",<newline>    )<newline>    subparser.add_argument(<newline>        ""--remove"",<newline>        action=""store_true"",<newline>        help=""""""Remove any cache entries matching the given resource patterns."""""",<newline>    )<newline>    return subparser"
407	adjudicated	label-na	"def _cached_path(args: argparse.Namespace):<newline>    logger.info(""Cache directory: %s"", args.cache_dir)<newline>    if args.inspect:<newline>        if args.extract_archive or args.force_extract or args.remove:<newline>            raise RuntimeError(<newline>                ""cached-path cannot accept --extract-archive, --force-extract, or --remove ""<newline>                ""options when --inspect flag is used.""<newline>            )<newline>        inspect_cache(patterns=args.resources, cache_dir=args.cache_dir)<newline>    elif args.remove:<newline>        from allennlp.common.util import format_size"
408	adjudicated	label-na	"class CheckList(Subcommand):  # type: ignore<newline>    def add_subparser(self, parser: argparse._SubParsersAction) -> argparse.ArgumentParser:<newline>        description = """"""Dummy command because checklist is not installed.""""""<newline>        subparser = parser.add_parser(<newline>            self.name,<newline>            description=description,<newline>            help=""Run a trained classifier through a checklist suite."",<newline>        )<newline>        subparser.set_defaults(func=_dummy_output)<newline>        return subparser"
409	adjudicated	label-na	"def _dummy_output(args: argparse.Namespace):<newline>   logger.info(<newline>        ""The checklist integration of allennlp is optional; if you're using conda, ""<newline>        ""it can be installed with `conda install allennlp-checklist`, ""<newline>        ""otherwise use `pip install allennlp[checklist]`.""<newline>    )"
410	adjudicated	label-na	"def add_subparser(self,<newline>                  parser: argparse._SubParsersAction) -> argparse.ArgumentParser:<newline>    description = """"""Dummy command because checklist is not installed.""""""<newline>    subparser = parser.add_parser(<newline>        self.name,<newline>        description=description,<newline>        help=""Run a trained model through a checklist suite."",<newline>    )<newline>    subparser.set_defaults(func=_dummy_output)<newline>    return subparser"
411	adjudicated	label-na	"def pgcli_bindings(pgcli):<newline>    """"""Custom key bindings for pgcli.""""""<newline>    kb = KeyBindings()"
412	adjudicated	label-na	"def _(event):<newline>    """"""Enable/Disable SmartCompletion Mode.""""""<newline>    _logger.debug(""Detected F2 key."")<newline>    pgcli.completer.smart_completion = not pgcli.completer.smart_completion"
413	adjudicated	label-na	"def _(event):<newline>    """"""Enable/Disable Multiline Mode.""""""<newline>    _logger.debug(""Detected F3 key."")<newline>    pgcli.multi_line = not pgcli.multi_line"
414	adjudicated	label-na	"def _(event):<newline>    """"""Toggle between Vi and Emacs mode.""""""<newline>    _logger.debug(""Detected F4 key."")<newline>    pgcli.vi_mode = not pgcli.vi_mode<newline>    event.app.editing_mode = EditingMode.VI if pgcli.vi_mode else EditingMode.EMACS"
415	adjudicated	label-na	"def _(event):<newline>    """"""Toggle between Vi and Emacs mode.""""""<newline>    _logger.debug(""Detected F5 key."")<newline>    pgcli.explain_mode = not pgcli.explain_mode"
416	adjudicated	label-na	"def keyring_initialize(keyring_enabled, *, logger):<newline>    """"""Initialize keyring only if explicitly enabled""""""<newline>    global keyring<newline>    """""""
417	adjudicated	label-na	"def keyring_get_password(key):<newline>    """"""Attempt to get password from keyring""""""<newline>    # Find password from store<newline>    passwd = """"<newline>    try:<newline>        passwd = keyring.get_password(""pgcli"", key) or """"<newline>    except Exception as e:<newline>        click.secho(<newline>            keyring_error_message.format(<newline>                ""Load your password from keyring returned:"", str(e)<newline>            ),<newline>            err=True,<newline>            fg=""red"",<newline>        )<newline>    return passwd"
418	adjudicated	label-na	"def keyring_set_password(key, passwd):<newline>    try:<newline>        keyring.set_password(""pgcli"", key, passwd)<newline>    except Exception as e:<newline>        click.secho(<newline>            keyring_error_message.format(""Set password in keyring returned:"", str(e)),<newline>            err=True,<newline>            fg=""red"",<newline>        )"
419	adjudicated	label-na	"def config_location():<newline>    if ""XDG_CONFIG_HOME"" in os.environ:<newline>        return ""%s/pgcli/"" % expanduser(os.environ[""XDG_CONFIG_HOME""])<newline>    elif platform.system() == ""Windows"":<newline>        return os.getenv(""USERPROFILE"") + ""\\AppData\\Local\\dbcli\\pgcli\\""<newline>    else:<newline>        return expanduser(""~/.config/pgcli/"")"
420	adjudicated	label-na	"def load_config(usr_cfg, def_cfg=None):<newline>    # avoid config merges when possible. For writing, we need an umerged config instance.<newline>    # see https://github.com/dbcli/pgcli/issues/1240 and https://github.com/DiffSK/configobj/issues/171<newline>    if def_cfg:<newline>        cfg = ConfigObj()<newline>        cfg.merge(ConfigObj(def_cfg, interpolation=False))<newline>        cfg.merge(ConfigObj(expanduser(usr_cfg), interpolation=False, encoding=""utf-8""))<newline>    else:<newline>        cfg = ConfigObj(expanduser(usr_cfg), interpolation=False, encoding=""utf-8"")<newline>    cfg.filename = expanduser(usr_cfg)<newline>    return cfg"
421	adjudicated	label-na	def ensure_dir_exists(path):<newline>    parent_dir = expanduser(dirname(path))<newline>    os.makedirs(parent_dir, exist_ok=True)
422	adjudicated	label-na	def write_default_config(source, destination, overwrite=False):<newline>    destination = expanduser(destination)<newline>    if not overwrite and exists(destination):<newline>        return
423	adjudicated	label-na	def upgrade_config(config, def_config):<newline>    cfg = load_config(config, def_config)<newline>    cfg.write()
424	adjudicated	label-na	class ExplainOutputFormatter:<newline>    def __init__(self, max_width):<newline>        self.max_width = max_width
425	adjudicated	label-na	def __init__(self, max_width):<newline>    self.max_width = max_width
426	adjudicated	label-na	def format_output(self, cur, headers, **output_kwargs):<newline>    # explain query results should always contain 1 row each<newline>    [(data,)] = list(cur)<newline>    explain_list = json.loads(data)<newline>    visualizer = Visualizer(self.max_width)<newline>    for explain in explain_list:<newline>        visualizer.load(explain)<newline>        yield visualizer.get_list()
427	adjudicated	label-na	"def load_ipython_extension(ipython):<newline>    """"""This is called via the ipython command '%load_ext pgcli.magic'"""""""
428	adjudicated	label-na	"def pgcli_line_magic(line):<newline>    _logger.debug(""pgcli magic called: %r"", line)<newline>    parsed = sql.parse.parse(line, {})<newline>    # ""get"" was renamed to ""set"" in ipython-sql:<newline>    # https://github.com/catherinedevlin/ipython-sql/commit/f4283c65aaf68f961e84019e8b939e4a3c501d43<newline>    if hasattr(sql.connection.Connection, ""get""):<newline>        conn = sql.connection.Connection.get(parsed[""connection""])<newline>    else:<newline>        try:<newline>            conn = sql.connection.Connection.set(parsed[""connection""])<newline>        # a new positional argument was added to Connection.set in version 0.4.0 of ipython-sql<newline>        except TypeError:<newline>            conn = sql.connection.Connection.set(parsed[""connection""], False)"
429	adjudicated	label-na	class CompletionRefresher:<newline>    refreshers = OrderedDict()
430	adjudicated	label-na	def __init__(self):<newline>    self._completer_thread = None<newline>    self._restart_refresh = threading.Event()
431	adjudicated	label-na	"def refresh(self, executor, special, callbacks, history=None, settings=None):<newline>    """"""<newline>    Creates a PGCompleter object and populates it with the relevant<newline>    completion suggestions in a background thread.<newline>    """""""
432	adjudicated	label-na	def is_refreshing(self):<newline>    return self._completer_thread and self._completer_thread.is_alive()
433	adjudicated	label-na	def _bg_refresh(self, pgexecute, special, callbacks, history=None, settings=None):<newline>    settings = settings or {}<newline>    completer = PGCompleter(<newline>        smart_completion=True, pgspecial=special, settings=settings<newline>    )
434	adjudicated	label-na	class CustomOutputChecker(OutputChecker):<newline>    def check_output(self, want, got, optionflags):<newline>        if IGNORE_RESULT & optionflags:<newline>            return True<newline>        return OutputChecker.check_output(self, want, got, optionflags)
435	adjudicated	label-na	"def pytest_configure(config):<newline>    config.addinivalue_line(<newline>        ""markers"", ""is_pt_tf_cross_test: mark test to run only when PT and TF interactions are tested""<newline>    )<newline>    config.addinivalue_line(<newline>        ""markers"", ""is_pt_flax_cross_test: mark test to run only when PT and FLAX interactions are tested""<newline>    )<newline>    config.addinivalue_line(<newline>        ""markers"", ""is_pipeline_test: mark test to run only when pipelines are tested""<newline>    )<newline>    config.addinivalue_line(""markers"", ""is_staging_test: mark test to run only in the staging environment"")"
436	adjudicated	label-na	def pytest_addoption(parser):<newline>    from transformers.testing_utils import pytest_addoption_shared
437	adjudicated	label-na	def pytest_terminal_summary(terminalreporter):<newline>    from transformers.testing_utils import pytest_terminal_summary_main
438	adjudicated	label-na	def pytest_sessionfinish(session, exitstatus):<newline>    # If no tests are collected, pytest exists with code 5, which makes the CI fail.<newline>    if exitstatus == 5:<newline>        session.exitstatus = 0
439	adjudicated	label-na	"class CircleCIJob:<newline>    name: str<newline>    additional_env: Dict[str, Any] = None<newline>    cache_name: str = None<newline>    cache_version: str = ""0.6""<newline>    docker_image: List[Dict[str, str]] = None<newline>    install_steps: List[str] = None<newline>    marker: Optional[str] = None<newline>    parallelism: Optional[int] = 1<newline>    pytest_num_workers: int = 8<newline>    pytest_options: Dict[str, Any] = None<newline>    resource_class: Optional[str] = ""xlarge""<newline>    tests_to_run: Optional[List[str]] = None<newline>    working_directory: str = ""~/transformers"""
440	adjudicated	label-na	def __post_init__(self):<newline>    # Deal with defaults for mutable attributes.<newline>    if self.additional_env is None:<newline>        self.additional_env = {}<newline>    if self.cache_name is None:<newline>        self.cache_name = self.name<newline>    if self.docker_image is None:<newline>        # Let's avoid changing the default list and make a copy.<newline>        self.docker_image = copy.deepcopy(DEFAULT_DOCKER_IMAGE)<newline>    if self.install_steps is None:<newline>        self.install_steps = []<newline>    if self.pytest_options is None:<newline>        self.pytest_options = {}<newline>    if isinstance(self.tests_to_run, str):<newline>        self.tests_to_run = [self.tests_to_run]<newline>    if self.parallelism is None:<newline>        self.parallelism = 1
441	adjudicated	label-na	"def to_dict(self):<newline>    env = COMMON_ENV_VARIABLES.copy()<newline>    env.update(self.additional_env)<newline>    job = {<newline>        ""working_directory"": self.working_directory,<newline>        ""docker"": self.docker_image,<newline>        ""environment"": env,<newline>    }<newline>    if self.resource_class is not None:<newline>        job[""resource_class""] = self.resource_class<newline>    if self.parallelism is not None:<newline>        job[""parallelism""] = self.parallelism<newline>    steps = [<newline>        ""checkout"",<newline>        {""attach_workspace"": {""at"": ""~/transformers/test_preparation""}},<newline>        {<newline>            ""restore_cache"": {<newline>                ""keys"": [<newline>                    f""v{self.cache_version}-{self.cache_name}-"" + '{{ checksum ""setup.py"" }}',<newline>                    f""v{self.cache_version}-{self.cache_name}-"",<newline>                ]<newline>            }<newline>        },<newline>    ]<newline>    steps.extend([{""run"": l} for l in self.install_steps])<newline>    steps.append(<newline>        {<newline>            ""save_cache"": {<newline>                ""key"": f""v{self.cache_version}-{self.cache_name}-"" + '{{ checksum ""setup.py"" }}',<newline>                ""paths"": [""~/.cache/pip""],<newline>            }<newline>        }<newline>    )<newline>    steps.append({""run"": {""name"": ""Show installed libraries and their versions"",<newline>                          ""command"": ""pip freeze | tee installed.txt""}})<newline>    steps.append({""store_artifacts"": {""path"": ""~/transformers/installed.txt""}})"
442	adjudicated	label-na	"def job_name(self):<newline>    return self.name if ""examples"" in self.name else f""tests_{self.name}"""
443	adjudicated	label-na	"def create_circleci_config(folder=None):<newline>    if folder is None:<newline>        folder = os.getcwd()<newline>    # Used in CircleCIJob.to_dict() to expand the test list (for using parallelism)<newline>    os.environ[""test_preparation_dir""] = folder<newline>    jobs = []<newline>    all_test_file = os.path.join(folder, ""test_list.txt"")<newline>    if os.path.exists(all_test_file):<newline>        with open(all_test_file) as f:<newline>            all_test_list = f.read()<newline>    else:<newline>        all_test_list = []<newline>    if len(all_test_list) > 0:<newline>        jobs.extend(PIPELINE_TESTS)"
444	adjudicated	label-na	"def hello(name: str = ""world""):<newline>    prefect.get_run_logger().info(f""Hello {name}!"")"
445	adjudicated	label-na	async def apply_deployment_20(deployment):<newline>    async with prefect.get_client() as client:<newline>        flow_id = await client.create_flow_from_name(deployment.flow_name)<newline>        return await client.create_deployment(<newline>            flow_id=flow_id,<newline>            name=deployment.name,<newline>            path=deployment.path,<newline>            entrypoint=deployment.entrypoint,<newline>        )
446	adjudicated	label-na	"async def create_flow_run(deployment_id):<newline>    async with prefect.get_client() as client:<newline>        return await client.create_flow_run_from_deployment(<newline>            deployment_id, parameters={""name"": ""integration tests""}<newline>        )"
447	adjudicated	label-na	async def read_flow_run(flow_run_id):<newline>    async with prefect.get_client() as client:<newline>        return await client.read_flow_run(flow_run_id)
448	adjudicated	label-na	"def main():<newline>    # Create deployment<newline>    if Version(prefect.__version__) < Version(""2.1.0""):<newline>        deployment = Deployment(<newline>            name=""test-deployment"",<newline>            flow_name=hello.name,<newline>            parameter_openapi_schema=parameter_schema(hello),<newline>            path=str(pathlib.Path(__file__).parent),<newline>            entrypoint=f""{__file__}:hello"",<newline>        )<newline>        deployment_id = anyio.run(apply_deployment_20, deployment)<newline>    else:<newline>        deployment = Deployment.build_from_flow(flow=hello, name=""test-deployment"")<newline>        deployment_id = deployment.apply()"
449	adjudicated	label-na	"def hello(name: str = ""world""):<newline>    prefect.get_run_logger().info(f""Hello {name}!"")"
450	adjudicated	label-na	async def apply_deployment(deployment):<newline>    async with prefect.get_client() as client:<newline>        flow_id = await client.create_flow_from_name(deployment.flow_name)<newline>        await client.create_deployment(flow_id=flow_id, name=deployment.name)
451	adjudicated	label-na	def noop_function():<newline>    pass
452	adjudicated	label-na	def bench_task_decorator(benchmark: BenchmarkFixture):<newline>    benchmark(task, noop_function)
453	adjudicated	label-na	def bench_task_call(benchmark: BenchmarkFixture):<newline>    noop_task = task(noop_function)
454	adjudicated	label-na	def benchmark_flow():<newline>    benchmark(noop_task)
455	adjudicated	label-na	def bench_task_submit(benchmark: BenchmarkFixture, num_task_runs: int):<newline>    noop_task = task(noop_function)
456	adjudicated	label-na	"def reset_object_registry():<newline>    """"""<newline>    Ensures each test has a clean object registry.<newline>    """"""<newline>    from prefect.context import PrefectObjectRegistry"
457	adjudicated	label-na	def noop_function():<newline>    pass
458	adjudicated	label-na	async def anoop_function():<newline>    pass
459	adjudicated	label-na	def bench_flow_decorator(benchmark: BenchmarkFixture):<newline>    benchmark(flow, noop_function)
460	adjudicated	label-na	def bench_flow_call(benchmark: BenchmarkFixture, options):<newline>    noop_flow = flow(**options)(noop_function)<newline>    benchmark(noop_flow)
461	adjudicated	label-na	def bench_flow_with_submitted_tasks(benchmark: BenchmarkFixture, num_tasks: int):<newline>    test_task = task(noop_function)
462	adjudicated	label-na	def convert(mxnet_name, torch_name):<newline>    # download and load the pre-trained classifier<newline>    net = gluoncv.model_zoo.get_model(mxnet_name, pretrained=True)
463	adjudicated	label-na	def map_mx_to_torch_model(mx_name):<newline>    torch_name = mx_name.lower()<newline>    if torch_name.startswith('se_'):<newline>        torch_name = torch_name.replace('se_', 'se')<newline>    elif torch_name.startswith('senet_'):<newline>        torch_name = torch_name.replace('senet_', 'senet')<newline>    elif torch_name.startswith('inceptionv3'):<newline>        torch_name = torch_name.replace('inceptionv3', 'inception_v3')<newline>    torch_name = 'gluon_' + torch_name<newline>    return torch_name
464	adjudicated	label-na	def main():<newline>    args = parser.parse_args()
465	adjudicated	label-na	"def convert_nest(checkpoint_path, arch):<newline>    """"""<newline>    Expects path to checkpoint which is a dir containing 4 files like in each of these folders<newline>        - https://console.cloud.google.com/storage/browser/gresearch/nest-checkpoints<newline>    `arch` is needed to <newline>    Returns a state dict that can be used with `torch.nn.Module.load_state_dict`<newline>    Hint: Follow timm.models.nest.Nest.__init__ and <newline>    https://github.com/google-research/nested-transformer/blob/main/models/nest_net.py<newline>    """"""<newline>    assert arch in ['nest_base', 'nest_small', 'nest_tiny'], ""Your `arch` is not supported"""
466	adjudicated	label-na	class BenchmarkRunner:<newline>    def __init__(<newline>            self,<newline>            model_name,<newline>            detail=False,<newline>            device='cuda',<newline>            torchscript=False,<newline>            torchcompile=None,<newline>            aot_autograd=False,<newline>            precision='float32',<newline>            fuser='',<newline>            num_warm_iter=10,<newline>            num_bench_iter=50,<newline>            use_train_size=False,<newline>            **kwargs<newline>    ):<newline>        self.model_name = model_name<newline>        self.detail = detail<newline>        self.device = device<newline>        self.amp_dtype, self.model_dtype, self.data_dtype = resolve_precision(precision)<newline>        self.channels_last = kwargs.pop('channels_last', False)<newline>        if self.amp_dtype is not None:<newline>            self.amp_autocast = partial(torch.cuda.amp.autocast, dtype=self.amp_dtype)<newline>        else:<newline>            self.amp_autocast = suppress
467	adjudicated	label-na	class InferenceBenchmarkRunner(BenchmarkRunner):
468	adjudicated	label-na	class TrainBenchmarkRunner(BenchmarkRunner):
469	adjudicated	label-na	class ProfileRunner(BenchmarkRunner):
470	adjudicated	label-na	def timestamp(sync=False):<newline>    return time.perf_counter()
471	adjudicated	label-na	"def cmd_from_args(args) -> Tuple[Union[Callable, str], List[str]]:<newline>    # If ``args`` not passed, defaults to ``sys.argv[:1]``<newline>    with_python = not args.no_python<newline>    cmd: Union[Callable, str]<newline>    cmd_args = []<newline>    if with_python:<newline>        cmd = os.getenv(""PYTHON_EXEC"", sys.executable)<newline>        cmd_args.append(""-u"")<newline>        if args.module:<newline>            cmd_args.append(""-m"")<newline>        cmd_args.append(args.script)<newline>    else:<newline>        if args.module:<newline>            raise ValueError(<newline>                ""Don't use both the '--no_python' flag""<newline>                "" and the '--module' flag at the same time.""<newline>            )<newline>        cmd = args.script<newline>    cmd_args.extend(args.script_args)"
472	adjudicated	label-na	def main():<newline>    args = parser.parse_args()<newline>    cmd, cmd_args = cmd_from_args(args)
473	adjudicated	label-na	def write_results(results_file, results):<newline>    with open(results_file, mode='w') as cf:<newline>        dw = csv.DictWriter(cf, fieldnames=results[0].keys())<newline>        dw.writeheader()<newline>        for r in results:<newline>            dw.writerow(r)<newline>        cf.flush()
474	adjudicated	label-na	"def checkpoint_metric(checkpoint_path):<newline>    if not checkpoint_path or not os.path.isfile(checkpoint_path):<newline>        return {}<newline>    print(""=> Extracting metric from checkpoint '{}'"".format(checkpoint_path))<newline>    checkpoint = torch.load(checkpoint_path, map_location='cpu')<newline>    metric = None<newline>    if 'metric' in checkpoint:<newline>        metric = checkpoint['metric']<newline>    elif 'metrics' in checkpoint and 'metric_name' in checkpoint:<newline>        metrics = checkpoint['metrics']<newline>        print(metrics)<newline>        metric = metrics[checkpoint['metric_name']]<newline>    return metric"
475	adjudicated	label-na	def main():<newline>    args = parser.parse_args()<newline>    # by default use the EMA weights (if present)<newline>    args.use_ema = not args.no_use_ema<newline>    # by default sort by checkpoint metric (if present) and avg top n checkpoints<newline>    args.sort = not args.no_sort
476	adjudicated	label-na	"def generate_readmes(templates_path: Path, dest_path: Path):<newline>    """"""Add the code snippet template to the readmes""""""<newline>    readme_templates_path = templates_path / ""models""<newline>    code_template_path = templates_path / ""code_snippets.md"""
477	adjudicated	label-na	"def main():<newline>    parser = argparse.ArgumentParser(description=""Model index generation config"")<newline>    parser.add_argument(<newline>        ""-t"",<newline>        ""--templates"",<newline>        default=Path(__file__).parent / "".templates"",<newline>        type=str,<newline>        help=""Location of the markdown templates"",<newline>    )<newline>    parser.add_argument(<newline>        ""-d"",<newline>        ""--dest"",<newline>        default=Path(__file__).parent / ""models"",<newline>        type=str,<newline>        help=""Destination folder that contains the generated model-index files."",<newline>    )<newline>    args = parser.parse_args()<newline>    templates_path = Path(args.templates)<newline>    dest_readmes_path = Path(args.dest)"
478	adjudicated	label-na	def main():<newline>    args = parser.parse_args()
479	adjudicated	label-na	"def clean_checkpoint(<newline>        checkpoint,<newline>        output,<newline>        use_ema=True,<newline>        no_hash=False,<newline>        clean_aux_bn=False,<newline>        safe_serialization: bool=False,<newline>):<newline>    # Load an existing checkpoint to CPU, strip everything but the state_dict and re-save<newline>    if checkpoint and os.path.isfile(checkpoint):<newline>        print(""=> Loading checkpoint '{}'"".format(checkpoint))<newline>        state_dict = load_state_dict(checkpoint, use_ema=use_ema)<newline>        new_state_dict = {}<newline>        for k, v in state_dict.items():<newline>            if clean_aux_bn and 'aux_bn' in k:<newline>                # If all aux_bn keys are removed, the SplitBN layers will end up as normal and<newline>                # load with the unmodified classifier using BatchNorm2d.<newline>                continue<newline>            name = k[7:] if k.startswith('module.') else k<newline>            new_state_dict[name] = v<newline>        print(""=> Loaded state_dict from '{}'"".format(checkpoint))"
480	adjudicated	label-na	"def pytest_addoption(parser):<newline>    parser.addoption(""--runslow"", action=""store_true"", help=""run slow tests"")"
481	adjudicated	label-na	"def pytest_runtest_setup(item):<newline>    if ""slow"" in item.keywords and not item.config.getoption(""--runslow""):<newline>        pytest.skip(""need --runslow option to run"")"
482	adjudicated	label-na	"def pytest_collection_modifyitems(config, items):<newline>    for item in items:<newline>        if ""skip_with_pyarrow_strings"" in item.keywords:<newline>            item.add_marker(skip_with_pyarrow_strings)<newline>        if ""xfail_with_pyarrow_strings"" in item.keywords:<newline>            item.add_marker(xfail_with_pyarrow_strings)"
483	adjudicated	label-na	"def shuffle_method(request):<newline>    with dask.config.set({""dataframe.shuffle.method"": request.param}):<newline>        yield request.param"
484	adjudicated	label-na	class NumpyBackendEntrypoint(ArrayBackendEntrypoint):<newline>    @classmethod<newline>    def to_backend_dispatch(cls):<newline>        return to_numpy_dispatch
485	adjudicated	label-na	"def percentile(a, q, method=""linear""):<newline>    return _percentile(a, q, method)"
486	adjudicated	label-na	"def _concatenate(arrays, axis=0):<newline>    out = np.ma.concatenate(arrays, axis=axis)<newline>    fill_values = [i.fill_value for i in arrays if hasattr(i, ""fill_value"")]<newline>    if any(isinstance(f, np.ndarray) for f in fill_values):<newline>        raise ValueError(<newline>            ""Dask doesn't support masked array's with non-scalar `fill_value`s""<newline>        )<newline>    if fill_values:<newline>        # If all the fill_values are the same copy over the fill value<newline>        fill_values = np.unique(fill_values)<newline>        if len(fill_values) == 1:<newline>            out.fill_value = fill_values[0]<newline>    return out<newline>"
487	adjudicated	label-na	def _tensordot(a, b, axes=2):<newline>    # Much of this is stolen from numpy/core/numeric.py::tensordot<newline>    # Please see license at https://github.com/numpy/numpy/blob/master/LICENSE.txt<newline>    try:<newline>        iter(axes)<newline>    except TypeError:<newline>        axes_a = list(range(-axes, 0))<newline>        axes_b = list(range(0, axes))<newline>    else:<newline>        axes_a, axes_b = axes<newline>    try:<newline>        na = len(axes_a)<newline>        axes_a = list(axes_a)<newline>    except TypeError:<newline>        axes_a = [axes_a]<newline>        na = 1<newline>    try:<newline>        nb = len(axes_b)<newline>        axes_b = list(axes_b)<newline>    except TypeError:<newline>        axes_b = [axes_b]<newline>        nb = 1
488	adjudicated	label-na	"def keepdims_wrapper(a_callable):<newline>    """"""<newline>    A wrapper for functions that don't provide keepdims to ensure that they do.<newline>    """""""
489	adjudicated	label-na	def keepdims_wrapped_callable(x, axis=None, keepdims=None, *args, **kwargs):<newline>    r = a_callable(x, *args, axis=axis, **kwargs)
490	adjudicated	label-na	"def coarsen(reduction, x, axes, trim_excess=False, **kwargs):<newline>    """"""Coarsen array by applying reduction to fixed size neighborhoods<newline>    """""""
491	adjudicated	label-na	"def trim(x, axes=None):<newline>    """"""Trim boundaries off of array<newline>    """""""
492	adjudicated	label-na	"def topk(a, k, axis, keepdims):<newline>    """"""Chunk and combine function of topk<newline>    """""""
493	adjudicated	label-na	"def blockwise(<newline>    func,<newline>    out_ind,<newline>    *args,<newline>    name=None,<newline>    token=None,<newline>    dtype=None,<newline>    adjust_chunks=None,<newline>    new_axes=None,<newline>    align_arrays=True,<newline>    concatenate=None,<newline>    meta=None,<newline>    **kwargs,<newline>):<newline>    """"""Tensor operation: Generalized inner and outer products<newline>        >>> def sequence_dot(a_blocks, b_blocks):<newline>    ...     result = 0<newline>    ...     for a, b in zip(a_blocks, b_blocks):<newline>    ...         result += a.dot(b)<newline>    ...     return result<newline>    >>> def f(a):<newline>    ...     return a[:, None] * np.ones((1, 5))<newline>    >>> def double(x):<newline>    ...     return np.concatenate([x, x])<newline>    """"""<newline><newline>"
494	adjudicated	label-na	def main():<newline>    run_cli()
495	adjudicated	label-na	"class VersioneerConfig:<newline>    """"""Container for Versioneer configuration parameters."""""""
496	adjudicated	label-na	"class NotThisMethod(Exception):<newline>    """"""Exception raised if a method is not valid for the current scenario."""""""
497	adjudicated	label-na	"def get_keywords():<newline>    """"""Get the keywords needed to look up the version information.""""""<newline>    # these strings will be replaced by git during git-archive.<newline>    # setup.py/versioneer.py will grep for the variable names, so they must<newline>    # each be defined on a line of their own. _version.py will just call<newline>    # get_keywords().<newline>    git_refnames = ""$Format:%d$""<newline>    git_full = ""$Format:%H$""<newline>    keywords = {""refnames"": git_refnames, ""full"": git_full}<newline>    return keywords"
498	adjudicated	label-na	"def get_config():<newline>    """"""Create, populate and return the VersioneerConfig() object.""""""<newline>    # these strings are filled in when 'setup.py versioneer' creates<newline>    # _version.py<newline>    cfg = VersioneerConfig()<newline>    cfg.VCS = ""git""<newline>    cfg.style = ""pep440""<newline>    cfg.tag_prefix = """"<newline>    cfg.parentdir_prefix = ""dask-""<newline>    cfg.versionfile_source = ""dask/_version.py""<newline>    cfg.verbose = False<newline>    return cfg"
499	adjudicated	label-na	"def register_vcs_handler(vcs, method):  # decorator<newline>    """"""Decorator to mark a method as the handler for a particular VCS."""""""