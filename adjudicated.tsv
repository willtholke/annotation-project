UID	Category	Snippet
psf|requests|api.py|000	Function	"def request(method, url, **kwargs):
    """"""Constructs and sends a :class:`Request <Request>`.
"
psf|requests|api.py|001	Function	"def get(url, params=None, **kwargs):
    r""""""Sends a GET request.
"
psf|requests|api.py|002	Function	"def options(url, **kwargs):
    r""""""Sends an OPTIONS request.
"
psf|requests|api.py|003	Function	"def head(url, **kwargs):
    r""""""Sends a HEAD request.
"
psf|requests|api.py|004	Function	"def post(url, data=None, json=None, **kwargs):
    r""""""Sends a POST request.
"
psf|requests|__init__.py|000	Function	"def check_compatibility(urllib3_version, chardet_version, charset_normalizer_version):
    urllib3_version = urllib3_version.split(""."")
    assert urllib3_version != [""dev""]  # Verify urllib3 isn't installed from git.
"
psf|requests|__init__.py|001	Function	"def _check_cryptography(cryptography_version):
    # cryptography < 1.3.4
    try:
        cryptography_version = list(map(int, cryptography_version.split(""."")))
    except ValueError:
        return
"
psf|requests|auth.py|000	Class	"class AuthBase:
    """"""Base class that all auth implementations derive from""""""
"
psf|requests|auth.py|001	Class	"    """"""Base class that all auth implementations derive from""""""
"
psf|requests|auth.py|002	Class	"class HTTPBasicAuth(AuthBase):
    """"""Attaches HTTP Basic Authentication to the given Request object.""""""
"
psf|requests|auth.py|003	Class	"class HTTPProxyAuth(HTTPBasicAuth):
    """"""Attaches HTTP Proxy Authentication to a given Request object.""""""
"
psf|requests|auth.py|004	Class	"class HTTPDigestAuth(AuthBase):
    """"""Attaches HTTP Digest Authentication to the given Request object.""""""
"
psf|requests|flask_theme_support.py|000	Class	"class FlaskyStyle(Style):
    background_color = ""#f8f8f8""
    default_style = """"
"
psf|requests|flask_theme_support.py|001	Class	"        # No corresponding class for the following:
        #Text:                     """", # class:  ''
        Whitespace:                ""underline #f8f8f8"",      # class: 'w'
        Error:                     ""#a40000 border:#ef2929"", # class: 'err'
        Other:                     ""#000000"",                # class 'x'
"
psf|requests|adapters.py|000	Class	"class BaseAdapter:
    """"""The Base Transport Adapter""""""
"
psf|requests|adapters.py|001	Class	"class HTTPAdapter(BaseAdapter):
    """"""The built-in HTTP Adapter for urllib3.
"
psf|requests|adapters.py|002	Class	"    HTTPS urls by implementing the Transport Adapter interface. This class will
    usually be created by the :class:`Session <Session>` class under the
    covers.
"
psf|requests|adapters.py|003	Class	"    usually be created by the :class:`Session <Session>` class under the
    covers.
"
psf|requests|adapters.py|004	Class	"        which we retry a request, import urllib3's ``Retry`` class and pass
        that instead.
    :param pool_block: Whether the connection pool should block for connections.
"
psf|requests|_internal_utils.py|000	Function	"def to_native_string(string, encoding=""ascii""):
    """"""Given a string object, regardless of type, returns a representation of
    that string in the native string type, encoding and decoding where
    necessary. This assumes ASCII unless told otherwise.
    """"""
    if isinstance(string, builtin_str):
        out = string
    else:
        out = string.decode(encoding)
"
psf|requests|_internal_utils.py|001	Function	"def unicode_is_ascii(u_string):
    """"""Determine if unicode string only contains ASCII characters.
"
huggingface|transformers|conftest.py|000	Class	"class CustomOutputChecker(OutputChecker):
    def check_output(self, want, got, optionflags):
        if IGNORE_RESULT & optionflags:
            return True
        return OutputChecker.check_output(self, want, got, optionflags)
"
huggingface|transformers|conftest.py|001	Function	"def pytest_configure(config):
    config.addinivalue_line(
        ""markers"", ""is_pt_tf_cross_test: mark test to run only when PT and TF interactions are tested""
    )
    config.addinivalue_line(
        ""markers"", ""is_pt_flax_cross_test: mark test to run only when PT and FLAX interactions are tested""
    )
    config.addinivalue_line(
        ""markers"", ""is_pipeline_test: mark test to run only when pipelines are tested""
    )
    config.addinivalue_line(""markers"", ""is_staging_test: mark test to run only in the staging environment"")
"
huggingface|transformers|conftest.py|002	Function	"def pytest_addoption(parser):
    from transformers.testing_utils import pytest_addoption_shared
"
huggingface|transformers|conftest.py|003	Function	"def pytest_terminal_summary(terminalreporter):
    from transformers.testing_utils import pytest_terminal_summary_main
"
huggingface|transformers|conftest.py|004	Function	"def pytest_sessionfinish(session, exitstatus):
    # If no tests are collected, pytest exists with code 5, which makes the CI fail.
    if exitstatus == 5:
        session.exitstatus = 0
"
huggingface|transformers|create_circleci_config.py|000	Class	"class CircleCIJob:
    name: str
    additional_env: Dict[str, Any] = None
    cache_name: str = None
    cache_version: str = ""0.6""
    docker_image: List[Dict[str, str]] = None
    install_steps: List[str] = None
    marker: Optional[str] = None
    parallelism: Optional[int] = 1
    pytest_num_workers: int = 8
    pytest_options: Dict[str, Any] = None
    resource_class: Optional[str] = ""xlarge""
    tests_to_run: Optional[List[str]] = None
    working_directory: str = ""~/transformers""
"
huggingface|transformers|create_circleci_config.py|001	Function	"    def __post_init__(self):
        # Deal with defaults for mutable attributes.
        if self.additional_env is None:
            self.additional_env = {}
        if self.cache_name is None:
            self.cache_name = self.name
        if self.docker_image is None:
            # Let's avoid changing the default list and make a copy.
            self.docker_image = copy.deepcopy(DEFAULT_DOCKER_IMAGE)
        if self.install_steps is None:
            self.install_steps = []
        if self.pytest_options is None:
            self.pytest_options = {}
        if isinstance(self.tests_to_run, str):
            self.tests_to_run = [self.tests_to_run]
        if self.parallelism is None:
            self.parallelism = 1
"
huggingface|transformers|create_circleci_config.py|002	Function	"    def to_dict(self):
        env = COMMON_ENV_VARIABLES.copy()
        env.update(self.additional_env)
        job = {
            ""working_directory"": self.working_directory,
            ""docker"": self.docker_image,
            ""environment"": env,
        }
        if self.resource_class is not None:
            job[""resource_class""] = self.resource_class
        if self.parallelism is not None:
            job[""parallelism""] = self.parallelism
        steps = [
            ""checkout"",
            {""attach_workspace"": {""at"": ""~/transformers/test_preparation""}},
            {
                ""restore_cache"": {
                    ""keys"": [
                        f""v{self.cache_version}-{self.cache_name}-"" + '{{ checksum ""setup.py"" }}',
                        f""v{self.cache_version}-{self.cache_name}-"",
                    ]
                }
            },
        ]
        steps.extend([{""run"": l} for l in self.install_steps])
        steps.append(
            {
                ""save_cache"": {
                    ""key"": f""v{self.cache_version}-{self.cache_name}-"" + '{{ checksum ""setup.py"" }}',
                    ""paths"": [""~/.cache/pip""],
                }
            }
        )
        steps.append({""run"": {""name"": ""Show installed libraries and their versions"", ""command"": ""pip freeze | tee installed.txt""}})
        steps.append({""store_artifacts"": {""path"": ""~/transformers/installed.txt""}})
"
huggingface|transformers|create_circleci_config.py|003	Function	"    def job_name(self):
        return self.name if ""examples"" in self.name else f""tests_{self.name}""
"
huggingface|transformers|create_circleci_config.py|004	Function	"def create_circleci_config(folder=None):
    if folder is None:
        folder = os.getcwd()
    # Used in CircleCIJob.to_dict() to expand the test list (for using parallelism)
    os.environ[""test_preparation_dir""] = folder
    jobs = []
    all_test_file = os.path.join(folder, ""test_list.txt"")
    if os.path.exists(all_test_file):
        with open(all_test_file) as f:
            all_test_list = f.read()
    else:
        all_test_list = []
    if len(all_test_list) > 0:
        jobs.extend(PIPELINE_TESTS)
"
